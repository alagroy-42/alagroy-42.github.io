<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Backdoor on Hacklagr0y</title>
    <link>https://alagroy-42.github.io/tags/backdoor/</link>
    <description>Recent content in Backdoor on Hacklagr0y</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 08 Jul 2022 17:25:14 +0200</lastBuildDate><atom:link href="https://alagroy-42.github.io/tags/backdoor/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>The payload: How to setup a simple backdoor on a computer</title>
      <link>https://alagroy-42.github.io/malware_dev/simple_backdoor/</link>
      <pubDate>Fri, 08 Jul 2022 17:25:14 +0200</pubDate>
      
      <guid>https://alagroy-42.github.io/malware_dev/simple_backdoor/</guid>
      <description>Introduction Now that we have made a stealthy infector that is able to infect any ELF binary present on our system, we now have to make it useful. Being able to propagate is a good thing but we want to make something out of it. A backdoor allowing remote access on the infected machine would be a great idea. How do we do that ? This actually quite simple. Here we won&amp;rsquo;t really take care about stealthiness but I might write an article about it at some point.</description>
      <content>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Now that we have made a stealthy infector that is able to infect any ELF binary present on our system, we now have to make it useful. Being able to propagate is a good thing but we want to make something out of it. A backdoor allowing remote access on the infected machine would be a great idea. How do we do that ? This actually quite simple. Here we won&amp;rsquo;t really take care about stealthiness but I might write an article about it at some point. The purpose of this backdoor will be to have an almost-permanent remote access on the machine. For that, we will assume that enough binaries are infected so that when the backdoor is closed, it will be reopened when the infected machine will run a command. I won&amp;rsquo;t show any code for this article but if you want to get a very similar backdoor ASM source code, you can find it &lt;a href=&#34;https://github.com/alagroy-42/Durex&#34;&gt;here&lt;/a&gt; in the Assembly files&lt;/p&gt;
&lt;h2 id=&#34;how-to-run-background-&#34;&gt;How to run background ?&lt;/h2&gt;
&lt;p&gt;First, what we have to do is making sure tht the backdoor will be running in background at any time. For that, we have to launch it via the viral code but we also want to make its execution continue after the virus/command has been executed. We can use the daemonization principle to do that (&lt;code&gt;man 7 daemon&lt;/code&gt;). A daemon is simply a process that runs in background. To make our program a daemon, we will first have to fork to detach from the main process to let it do its thing. Once we have done that, we will fork, make the child the session leader and then fork again without forgetting to kill the parent processes (except for the main thread of course). A last thing to do for our backdoor is to check that there is only one instance running (checking that before daemonizing would be great but it can be done afterwards). To check that the process is not already running, we can use UNIX socket. We will create one in &lt;code&gt;/var/lock&lt;/code&gt; because that is the right place to do it. Once it is created, we can try to connect to it. If we cannot, it means that another instance of the backdoor is running.&lt;/p&gt;
&lt;h2 id=&#34;what-about-rce-&#34;&gt;What about RCE ?&lt;/h2&gt;
&lt;p&gt;We now have the ability to run a single instance of the program in background and make it do what we want so what do we want it to do ? To allow remote code execution, the best solution is to use TCP socket. Those are used to open a port and listen for an incoming connection. Since we want to be able to connect to it, we have to specify the port and not let the system decide about it. That would also work to check that we have a single instance running since we cannot use a port several times unless we modify the socket options but that would not work if we want to make our backdoor a bit fancier and add some functionalities like multi-client handling. The advantage of that is that the &lt;code&gt;listen&lt;/code&gt; syscall will only return once it has received a connection so the backdoor will run indefinitely in background. Once this connection returns, it means a client has connected. Since our backdoor doesn&amp;rsquo;t do any fancy stuff like network traffic encoding for now, we don&amp;rsquo;t have to actually code a client and we can just use the &lt;code&gt;netcat&lt;/code&gt; command. Giving RCE to our new client will be very easy once this one is connected. We will redirect all the standard fds (stdin, stdout and stderr) to the socket using the &lt;code&gt;dup2&lt;/code&gt; syscall and once that is done, we will substitute our process by &lt;code&gt;/bin/sh&lt;/code&gt; using &lt;code&gt;execve&lt;/code&gt;. Do not forget to specify the &lt;code&gt;-i&lt;/code&gt; argument to &lt;code&gt;/bin/sh&lt;/code&gt; to make the process interactive so that the client receives a prompt.&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Good job, we made our very simple but also very effective backdoor. I might write another article later about how to make a more evolved backdoor that includes network-traffic encoding, ICMP exfiltration and other fancy features that will make it stealthier. Now that we have a proper malicious payload in our infector, let&amp;rsquo;s imagine that a reverse-engineer wants to try to check it out, it would be great to make its task harder with obfuscation. You can check that &lt;a href=&#34;https://alagroy-42.github.io/malware_dev/obfuscation_techniques&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
